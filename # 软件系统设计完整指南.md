# 软件系统设计完整指南

> 从需求到实现的系统化设计方法论

---

## 📑 目录导航

### 核心内容

- [🗺️ 设计全景图](#设计全景图)
- [🧠 设计思维三大工具](#设计思维三大工具)
  - [核心思维框架](#核心思维框架)
  - [三者关系与作用](#三者关系与作用)
  - [设计的哲学本质](#设计的哲学本质)

### 六大设计阶段

- [📋 阶段一：需求分析](#阶段一需求分析)
  - [核心活动](#核心活动)
  - [核心产物](#核心产物)
  - [高手心法](#高手心法)
  
- [🎯 阶段二：概念建模](#阶段二概念建模)
  - [Google Docs 概念建模示例](#google-docs-概念建模示例)
  - [关键原则](#关键原则)
  - [高手心法](#高手心法-1)
  
- [🏗️ 阶段三：模块拆解](#阶段三模块拆解高层设计)
  - [模块划分方法](#模块划分方法)
  - [模块职责定义](#模块职责定义)
  - [架构风格选择](#架构风格选择)
  - [高手心法](#高手心法-2)
  
- [⚙️ 阶段四：技术选型](#阶段四技术选型细节设计)
  - [基础设施决策](#基础设施决策)
  - [关键模块技术方案](#关键模块技术方案)
  - [性能优化策略](#性能优化策略)
  
- [🎯 阶段五：关键路径设计](#阶段五关键路径设计)
  - [为何强调关键路径](#为何强调关键路径)
  - [识别关键路径](#识别关键路径)
  - [关键路径详细设计示例](#关键路径详细设计示例)
  - [高手心法](#高手心法-3)
  
- [🔄 阶段六：可演进性设计](#阶段六可演进性设计)
  - [水平扩展与伸缩性](#1-水平扩展与伸缩性)
  - [模块解耦与可替换性](#2-模块解耦与可替换性)
  - [设计简洁性与复杂度控制](#3-设计简洁性与复杂度控制)
  - [容错与降级能力](#4-容错与降级能力)
  - [运维与升级能力](#5-运维与升级能力)
  - [高手心法](#高手心法-4)

### 方法论总结

- [📚 设计方法论总结](#设计方法论总结)
  - [核心设计原则](#核心设计原则)
  - [设计流程图](#设计流程图)
  - [常见陷阱和解决方案](#常见陷阱和解决方案)
  - [设计检查清单](#设计检查清单)

### 快速参考

- [📖 快速参考表](#快速参考表)
  - [设计阶段对照表](#设计阶段对照表)
  - [常用设计模式速查](#常用设计模式速查)

### 附录

- [💡 结语](#结语)
- [📝 使用建议](#使用建议)

---

## 🔗 快速导航

**按使用场景导航：**

- 🆕 **新手入门** → 先看 [设计思维三大工具](#设计思维三大工具) + [设计全景图](#设计全景图)
- 📋 **做需求分析** → 直达 [阶段一：需求分析](#阶段一需求分析)
- 🏗️ **设计架构** → 跳转 [阶段三：模块拆解](#阶段三模块拆解高层设计)
- ⚡ **性能优化** → 查看 [阶段五：关键路径设计](#阶段五关键路径设计)
- 🔄 **系统重构/演进** → 参考 [阶段六：可演进性设计](#阶段六可演进性设计)
- 📚 **系统学习** → 按顺序阅读六个阶段
- 🔍 **遇到问题** → 查阅 [常见陷阱和解决方案](#常见陷阱和解决方案)
- ✅ **设计评审** → 使用 [设计检查清单](#设计检查清单)

---

## 设计全景图

```
┌─────────────────────────────────────────────────────────────┐
│                     软件系统设计六阶段                        │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  阶段1: 需求分析 (What to Build)                              │
│  └─ 问题空间，理解要做什么                                    │
│           ↓                                                   │
│  阶段2: 概念建模 (What Concepts)                              │
│  └─ 识别核心业务概念                                          │
│           ↓                                                   │
│  阶段3: 模块拆解 (How to Organize) - 高层设计                 │
│  └─ 系统整体架构                                              │
│           ↓                                                   │
│  阶段4: 技术选型 (How to Implement) - 细节设计                │
│  └─ 具体实现方案                                              │
│           ↓                                                   │
│  阶段5: 关键路径设计 (Core Module Deep Dive)                  │
│  └─ 核心模块详细设计                                          │
│           ↓                                                   │
│  阶段6: 可演进性设计 (Future Evolution)                       │
│  └─ 着眼未来变化                                              │
│                                                               │
└─────────────────────────────────────────────────────────────┘
```

---

## 设计思维三大工具

### 核心思维框架

软件设计的本质在于:**在约束条件下,通过抽象和权衡,将一个复杂问题分解并组织成有序的方案**。具体来说,设计需要一方面"分"——把系统的问题域拆解为清晰的概念和模块,降低复杂度;另一方面"合"——将各部分有机组合以满足整体目标。

```
┌─────────────────────────────────────────────────────────────┐
│                    设计思维三大工具                           │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  工具1: 抽象化思维 (Abstraction)                              │
│  └─ 思维层面的简化,帮我们想清楚                              │
│     • 概念提取                                                │
│     • 简化认知                                                │
│     • 实现复用和扩展                                          │
│           ↓                                                   │
│  工具2: 模块化思维 (Modularization)                           │
│  └─ 结构层面的分解,帮我们做清楚                              │
│     • 系统分解                                                │
│     • 组织结构                                                │
│     • 便于维护和协作                                          │
│           ↓                                                   │
│  工具3: 动态化思维 (Evolution)                                │
│  └─ 处理软件变化演进,告诉我们如何适应变化                    │
│     • 生命周期管理                                            │
│     • 运行时演化                                              │
│     • 持续适应需求                                            │
│                                                               │
└─────────────────────────────────────────────────────────────┘
```

### 三者关系与作用

```
┌──────────────┬────────────┬────────────┬────────────┐
│ 维度         │ 抽象       │ 模块化     │ 动态化     │
├──────────────┼────────────┼────────────┼────────────┤
│ 本质         │ 简化认知   │ 组织结构   │ 适应变化   │
├──────────────┼────────────┼────────────┼────────────┤
│ 关注点       │ 概念提取   │ 系统分解   │ 演进能力   │
├──────────────┼────────────┼────────────┼────────────┤
│ 解决问题     │ 理解复杂性 │ 管理复杂性 │ 应对变化   │
├──────────────┼────────────┼────────────┼────────────┤
│ 作用层面     │ 思维/设计  │ 实现/组织  │ 运维/演进  │
├──────────────┼────────────┼────────────┼────────────┤
│ 回答问题     │ 做什么     │ 怎么组织   │ 如何变化   │
├──────────────┼────────────┼────────────┼────────────┤
│ 主要好处     │ 复用、扩展 │ 维护、协作 │ 弹性、升级 │
├──────────────┼────────────┼────────────┼────────────┤
│ 潜在风险     │ 过度抽象   │ 过度分解   │ 过度设计   │
└──────────────┴────────────┴────────────┴────────────┘

设计流程:
抽象思维    →  识别核心概念 (阶段1-2)
模块化思维  →  组织系统结构 (阶段3-4)
动态思维    →  保证演进能力 (阶段6)
```

### 设计的哲学本质

```
设计是一门平衡的艺术,体现在"分"与"合"的辩证关系:

"分" - 分而治之
  • 将复杂问题拆解为可管理的小问题
  • 通过抽象识别核心概念
  • 通过模块化划分职责边界
  • 降低单个部分的复杂度
  
"合" - 有机整合
  • 将各部分组织成协调的整体
  • 通过接口定义模块间协作
  • 通过架构保证整体一致性
  • 确保系统满足全局目标

平衡之道:
  • 分得太细 → 集成复杂,沟通成本高
  • 分得不够 → 模块臃肿,难以维护
  • 合得太紧 → 耦合严重,缺乏弹性
  • 合得太松 → 协作困难,无法保证一致性

高手的智慧:
  在"分"与"合"之间找到恰当的平衡点
  这需要对业务的深刻理解和对技术的娴熟把控
```

---

## 阶段一:需求分析

### 目标
**理解问题 - 明确要做什么(问题空间思考)**

### 核心活动

```
1. 理解目的和背景
   - 为什么要做这个系统?
   - 解决什么业务痛点?
   - 期望达到什么效果?

2. 确定功能需求
   - 编写Use Cases(用例)
   - 绘制Workflow(业务流程)
   - 识别核心功能点

3. 明确非功能需求
   - 性能指标
   - 可扩展性要求
   - 安全性标准
   - 可用性目标

4. 发现隐含需求
   - 通过提问挖掘未明说的期望
   - 澄清模糊和不确定的地方
   - 识别潜在风险

5. 确定优先级
   - 区分Must-have vs Nice-to-have
   - 识别核心价值路径
   - 制定分阶段实施计划

6. 明确边界和约束
   - 预算和成本限制
   - 技术栈要求
   - 时间窗口
   - 团队能力

7. 定义验收标准(AC)
   - 可衡量的成功指标
   - 测试验证方法
```

### 核心产物

```
1. 功能需求 (Functional Requirements)
   ┌──────────────────────────────────┐
   │ Use Case: 用户创建文档            │
   ├──────────────────────────────────┤
   │ 参与者: 登录用户                  │
   │ 前置条件: 已登录                  │
   │ 主流程:                          │
   │   1. 用户点击"新建文档"           │
   │   2. 系统创建空白文档             │
   │   3. 系统打开编辑器               │
   │   4. 用户输入内容                │
   │   5. 系统自动保存                │
   │ 异常流程:                        │
   │   5a. 网络断开，本地缓存         │
   └──────────────────────────────────┘

2. 业务流程 (Workflow)
   文档协作流程:
   创建文档 → 编辑内容 → 共享给他人 → 
   协作编辑 → 评论讨论 → 版本管理 → 发布

3. 非功能需求 (Non-Functional Requirements)
   ┌────────────┬─────────────────────┐
   │ 类型       │ 具体要求            │
   ├────────────┼─────────────────────┤
   │ 性能       │ 加载文档 < 2秒      │
   │ 可扩展性   │ 支持1000万用户      │
   │ 可用性     │ 99.9%在线时间       │
   │ 并发       │ 100人同时编辑       │
   │ 安全       │ 数据加密存储        │
   │ 兼容性     │ 支持主流浏览器      │
   └────────────┴─────────────────────┘
```

### 关键技巧

**Use Case vs Workflow 的区别**

```
Use Case (用例):
- 单一用户目标
- 用户与系统的交互
- 例子: "用户创建文档"

Workflow (工作流):
- 端到端业务流程
- 跨越多个角色和系统
- 例子: "文档从创建到发布的完整流程"

关系: 一个Workflow包含多个Use Case
```

### 高手心法

```
✓ 始终以"问题空间"为中心思考,不要过早跳到"解空间"
✓ 用新手般的好奇心去挖掘需求细节
✓ 善于追问和倾听,挖掘真实需求
✓ 当需求不明时,绝不贸然开始设计
✓ 区分客户说的需求 vs 真实需求
✓ 通过需求消化建立清晰的靶心
✓ 后续所有设计决策都要围绕这一靶心展开

陷阱警示:
✗ 过早考虑技术实现
✗ 被需求方的解决方案带偏
✗ 忽略非功能需求
✗ 没有明确优先级就全盘接受
```

**需求类型对比表**

```
┌──────────────┬────────────────┬────────────────┐
│              │ 功能需求       │ 非功能需求     │
├──────────────┼────────────────┼────────────────┤
│ 回答什么问题 │ 做什么？       │ 做得多好？     │
├──────────────┼────────────────┼────────────────┤
│ 关注点       │ 功能和行为     │ 质量属性       │
├──────────────┼────────────────┼────────────────┤
│ 例子         │ 用户可以编辑   │ 响应时间<2秒   │
│              │ 文档可以共享   │ 支持100人并发  │
│              │ 支持评论       │ 数据不能丢失   │
└──────────────┴────────────────┴────────────────┘
```

---

## 阶段二：概念建模

### 目标
**从需求中提取核心业务概念**

### Google Docs 概念建模示例

#### 步骤1: 从Use Case提取名词

```
Use Case: "用户创建文档并共享给团队成员"

提取名词:
- 用户 (User)          ✓
- 文档 (Document)      ✓
- 团队 (Team)          ✓
- 成员 (Member)        ✓
- 权限 (Permission)    ✓
- 版本 (Version)       ✓
- 评论 (Comment)       ✓
- 文件夹 (Folder)      ✓
```

#### 步骤2: 定义概念的属性和职责

```
概念: Document (文档)
├─ 属性 (数据)
│  ├─ document_id: 唯一标识
│  ├─ title: 标题
│  ├─ content: 内容
│  ├─ owner_id: 所有者
│  ├─ created_at: 创建时间
│  ├─ modified_at: 修改时间
│  └─ status: 状态（草稿/发布/归档）
│
└─ 职责 (行为)
   ├─ create(): 创建文档
   ├─ edit(): 编辑内容
   ├─ share(): 共享给他人
   ├─ add_comment(): 添加评论
   ├─ save_version(): 保存版本
   └─ is_editable(): 判断是否可编辑

概念: User (用户)
├─ 属性
│  ├─ user_id: 唯一标识
│  ├─ email: 邮箱
│  ├─ name: 姓名
│  └─ avatar: 头像
│
└─ 职责
   ├─ login(): 登录
   ├─ create_document(): 创建文档
   ├─ share_document(): 分享文档
   └─ has_permission(): 判断权限
```

#### 步骤3: 建立概念之间的关系

```
关系图:

User (用户)
 │
 ├─── owns ─────────► Document (文档)
 │                        │
 │                        ├─── contains ─► Version (版本)
 │                        │
 │                        └─── has ──────► Comment (评论)
 │
 ├─── belongs to ───► Team (团队)
 │
 └─── has ──────────► Permission (权限)
                           │
                           └─── on ──────► Document


文字描述:
- User owns Document (1对多)
- User belongs to Team (多对多)
- Document contains Version (1对多)
- Document has Comment (1对多)
- User has Permission on Document (多对多)
```

#### 步骤4: 验证模型完整性

```
用Use Case验证:

Use Case: "用户共享文档给团队"
✓ User 存在？              是
✓ Document 存在？          是
✓ Team 存在？              是
✓ Permission 存在？        是
✓ share() 方法存在？       是
✓ 所有步骤都能映射？       是

结论: 概念模型完整 ✓
```

### 关键原则

```
✓ 使用业务语言,不考虑技术实现
✓ 概念来自领域专家的术语
✓ 每个概念都应该在多个场景中使用
✓ 避免技术术语(不要叫 DocumentManager, DocumentService)
```

### 高手心法

```
✓ 概念建模要求抽象思维
✓ 站在业务场景之上观察,挑出重要事物加以抽象
✓ 不被偶然细节干扰
✓ 核心原则: "软件世界的结构应该映射现实世界"
✓ 只有在概念层面准确刻画业务,系统设计才有坚实基础

平衡之道:
避免两种极端:
  1. 过度抽象 - 发明脱离实际的概念
  2. 抽象不足 - 直接把需求细节当成概念

恰如其分的抽象来自:
  • 对业务本质的洞察
  • 合适的建模边界拿捏
  • 与领域专家形成统一语言(DDD思想)

实践建议:
  • 领域模型不必穷尽所有细枝末节
  • 只需包含核心概念和关系
  • 通过Use Case验证模型完整性
  • 保持概念的业务纯粹性
```

---

## 阶段三：模块拆解（高层设计）

### 目标
**将系统分解为可管理的模块**

### 模块划分方法

```
常见的模块划分方式:

1. 按业务功能垂直划分 ⭐推荐
   优点: 每个模块对应明确的业务领域
   例子: 用户模块、商品模块、订单模块、支付模块
   
2. 按技术层次水平划分
   优点: 分层职责清晰
   例子: 表示层(UI)、业务逻辑层、数据访问层
   
3. 按非功能需求拆分
   优点: 专注特定质量属性
   例子: 缓存服务、消息队列服务、身份认证服务

划分原则:
• 高内聚: 高度相关的功能和数据放在同一模块
• 低耦合: 关联弱的部分分离,通过接口交互
• 单一职责: 每个模块只负责一个明确的业务领域
• 独立演化: 模块可以独立开发、测试、部署
```

### Google Docs 模块划分

```
┌─────────────────────────────────────────────┐
│          Google Docs 系统架构                │
└─────────────────────────────────────────────┘
              │
              ├─► 用户模块 (User Module)
              │   ├─ 用户注册/登录
              │   ├─ 个人资料管理
              │   └─ 团队成员管理
              │
              ├─► 文档模块 (Document Module) ⭐核心
              │   ├─ 文档CRUD
              │   ├─ 实时协作编辑
              │   ├─ 版本控制
              │   └─ 格式化处理
              │
              ├─► 权限模块 (Permission Module)
              │   ├─ 权限验证
              │   ├─ 共享管理
              │   └─ 访问控制
              │
              ├─► 存储模块 (Storage Module)
              │   ├─ 文档存储
              │   ├─ 版本存储
              │   └─ 附件管理
              │
              ├─► 协作模块 (Collaboration Module)
              │   ├─ 实时同步
              │   ├─ 评论系统
              │   └─ 通知推送
              │
              └─► 搜索模块 (Search Module)
                  ├─ 全文搜索
                  └─ 文件夹浏览
```

### 模块职责定义

```
文档模块 (Document Module)
┌────────────────────────────────────┐
│ 职责:                              │
│ ✓ 管理文档生命周期                 │
│ ✓ 处理文档编辑操作                 │
│ ✓ 管理文档版本                     │
│ ✓ 提供文档查询接口                 │
│                                    │
│ 不负责 (边界):                     │
│ ✗ 用户认证 (User Module负责)      │
│ ✗ 权限检查 (Permission Module负责)│
│ ✗ 实际存储 (Storage Module负责)   │
│                                    │
│ 对外接口:                          │
│ - create_document()                │
│ - get_document()                   │
│ - update_document()                │
│ - delete_document()                │
│ - list_versions()                  │
│                                    │
│ 依赖:                              │
│ - Permission Module (验证权限)     │
│ - Storage Module (持久化)          │
│ - Collaboration Module (实时同步)  │
└────────────────────────────────────┘
```

### 模块间依赖关系

```
依赖层次图:

┌─────────────────────────────────────┐
│   Presentation Layer (API/UI)       │ ← 用户交互层
└─────────────────────────────────────┘
             ↓ 依赖
┌─────────────────────────────────────┐
│   Application Layer (Use Cases)     │ ← 应用层
│   - CreateDocumentUseCase           │
│   - ShareDocumentUseCase            │
└─────────────────────────────────────┘
             ↓ 依赖
┌─────────────────────────────────────┐
│   Domain Layer (Core Business)      │ ← 领域层
│   - Document, User, Permission      │
└─────────────────────────────────────┘
             ↑ 实现
┌─────────────────────────────────────┐
│   Infrastructure Layer              │ ← 基础设施层
│   - Database, Cache, MessageQueue   │
└─────────────────────────────────────┘

依赖原则:
✓ 高层依赖抽象接口
✓ 底层实现抽象接口
✓ 依赖方向向内（指向Domain）
```

### 架构风格选择

```
┌────────────┬─────────────┬─────────────┬─────────────┐
│ 项目规模   │ 推荐架构    │ 特点        │ 适用场景    │
├────────────┼─────────────┼─────────────┼─────────────┤
│ 小型       │ 简单分层    │ 快速开发    │ MVP、原型   │
│ (1-3人)    │ MVC模式     │ 易于理解    │             │
├────────────┼─────────────┼─────────────┼─────────────┤
│ 中型       │ DDD分层     │ 领域驱动    │ 复杂业务    │
│ (5-10人)   │ 清晰边界    │ 可维护性强  │ Google Docs │
├────────────┼─────────────┼─────────────┼─────────────┤
│ 大型       │ 微服务      │ 独立部署    │ 高并发      │
│ (10+人)    │ 技术异构    │ 团队独立    │ 分布式系统  │
└────────────┴─────────────┴─────────────┴─────────────┘

Google Docs 选择: DDD分层架构
原因: 业务复杂度高,需要清晰的领域模型
```

### 描述关键数据流

```
示例: Google Docs 文档编辑流程

用户编辑文档:
  1. 用户在前端输入内容
  2. 前端通过WebSocket发送操作到协作服务
  3. 协作服务通过OT引擎解决冲突
  4. 协作服务广播给其他在线用户
  5. 协作服务调用文档模块保存
  6. 文档模块调用存储模块持久化
  7. 文档模块调用版本模块创建快照
  8. 返回确认给用户

关键考量:
• 哪些步骤是同步的?
• 哪些步骤是异步的?
• 失败如何处理?
• 如何保证数据一致性?
```

### 高手心法

```
✓ 模块划分是一门平衡的艺术
✓ 好的架构像搭积木,各模块既内聚又能灵活组合
✓ 形散而神不散 - 表面独立,实际整体有序协作

权衡之道:
• 过度切分 → 沟通和集成成本上升
• 切分不足 → 无法隔离变化,难以扩展

优先策略:
• 优先拆分变化频繁的部分
• 优先拆分负载特殊的部分
• 把变化少、强相关的功能收拢在一起

核心目标: 在演进性和复杂度之间取得平衡

架构师自问:
"下一个数量级的增长,我们准备好了吗?"
"这个模块的边界清晰吗?"
"依赖关系简单吗?"
"能讲清楚为什么这样划分吗?"
```

---

## 阶段四:技术选型(细节设计)

### 目标
**为每个模块选择合适的技术实现**

### Google Docs 技术选型

#### 基础设施决策

```
┌──────────────┬─────────────────┬─────────────────┐
│ 技术领域     │ 选型            │ 理由            │
├──────────────┼─────────────────┼─────────────────┤
│ 数据库       │ PostgreSQL      │ ACID事务        │
│              │                 │ 支持JSON        │
│              │                 │ 全文搜索        │
├──────────────┼─────────────────┼─────────────────┤
│ 缓存         │ Redis           │ 高性能          │
│              │                 │ 支持数据结构    │
│              │                 │ 分布式锁        │
├──────────────┼─────────────────┼─────────────────┤
│ 消息队列     │ RabbitMQ        │ 可靠消息传递    │
│              │                 │ 支持多种模式    │
├──────────────┼─────────────────┼─────────────────┤
│ 文件存储     │ S3/GCS          │ 无限扩展        │
│              │                 │ 高可用          │
├──────────────┼─────────────────┼─────────────────┤
│ 实时通信     │ WebSocket       │ 双向通信        │
│              │                 │ 低延迟          │
├──────────────┼─────────────────┼─────────────────┤
│ 搜索引擎     │ Elasticsearch   │ 全文搜索        │
│              │                 │ 分布式          │
└──────────────┴─────────────────┴─────────────────┘
```

#### 关键模块技术方案

**1. 实时协作编辑**

```
技术挑战:
- 多人同时编辑冲突解决
- 低延迟同步
- 离线编辑支持

解决方案:

┌─────────────────────────────────────┐
│   Operational Transformation (OT)   │
│   操作转换算法                       │
├─────────────────────────────────────┤
│                                     │
│  用户A: 在位置5插入 "hello"         │
│  用户B: 在位置10删除3个字符         │
│                                     │
│  服务器: 转换操作，解决冲突         │
│                                     │
│  结果: 两个用户看到一致的文档       │
└─────────────────────────────────────┘

技术架构:
Client A ─┐
          ├──► WebSocket Server ──► OT Engine
Client B ─┘                             │
                                        ↓
                                   PostgreSQL
                                        │
                                        ↓
                                   Version Store
```

**2. 版本控制**

```
设计方案:

┌─────────────────────────────────────┐
│         版本存储策略                 │
├─────────────────────────────────────┤
│                                     │
│  方案1: 全量存储 (每个版本完整内容) │
│  ✓ 读取快                           │
│  ✗ 存储空间大                       │
│                                     │
│  方案2: 差异存储 (只存变化部分)     │
│  ✓ 节省空间                         │
│  ✗ 恢复慢                           │
│                                     │
│  混合方案 (Google Docs实际采用):    │
│  - 每10个版本全量存储               │
│  - 中间版本存差异                   │
│  - 平衡性能和空间                   │
└─────────────────────────────────────┘

数据结构:
Document
  └─ Versions
       ├─ V1 (full)
       ├─ V2 (delta)
       ├─ V3 (delta)
       ├─ ...
       ├─ V10 (full)
       ├─ V11 (delta)
       └─ ...
```

**3. 权限系统**

```
设计模式: RBAC (Role-Based Access Control)

┌─────────────────────────────────────┐
│            权限模型                  │
├─────────────────────────────────────┤
│                                     │
│  User ──has──► Role ──has──► Permission
│                │                    │
│                │                    │
│              Owner              View/Edit
│              Editor             Comment
│              Viewer              Share
│             Commenter            Delete
│                                     │
│  例子:                              │
│  User: alice@example.com           │
│  Role: Editor (on Doc123)          │
│  Permissions: View, Edit, Comment  │
└─────────────────────────────────────┘

权限检查流程:
Request → Authentication → Authorization → Operation
           (谁在访问)      (有什么权限)    (执行操作)
```

#### 性能优化策略

```
┌─────────────────────────────────────────┐
│          多层缓存架构                    │
├─────────────────────────────────────────┤
│                                         │
│  Layer 1: 浏览器缓存                    │
│  - 静态资源 (JS/CSS)                    │
│  - 文档元数据                           │
│           ↓                             │
│  Layer 2: CDN缓存                       │
│  - 图片、字体                           │
│  - 公开文档                             │
│           ↓                             │
│  Layer 3: 应用层缓存 (Redis)            │
│  - 热门文档内容                         │
│  - 用户会话                             │
│  - 权限信息                             │
│           ↓                             │
│  Layer 4: 数据库                        │
│  - 主数据存储                           │
│  - 读写分离                             │
└─────────────────────────────────────────┘

缓存策略:
- 文档内容: TTL 5分钟
- 权限信息: TTL 1分钟  
- 用户信息: TTL 10分钟
```

---

## 阶段五：关键路径设计

### 目标
**识别并详细设计最关键的模块**

### 为何强调关键路径

```
核心理念:
任何系统都有其"命脉"所在,保证了命脉的健壮和高效,
系统就成功了一大半。

二八定律:
把80%的精力用于解决那20%最具挑战的核心问题。

关键路径通常指:
• 最核心、对成败影响最大的用例
• 高频使用的核心业务流程
• 资源消耗最大的操作
• 技术挑战最高的模块
```

### 识别关键路径

```
模块重要性评估表:

┌──────────────┬──────┬──────┬──────┬──────┬──────┐
│ 模块         │技术  │性能  │业务  │用户  │ 总分 │
│              │难度  │要求  │核心  │影响  │      │
├──────────────┼──────┼──────┼──────┼──────┼──────┤
│ 实时协作编辑 │  10  │  10  │  10  │  10  │  40  │⭐
├──────────────┼──────┼──────┼──────┼──────┼──────┤
│ 版本控制     │   8  │   7  │   9  │   8  │  32  │⭐
├──────────────┼──────┼──────┼──────┼──────┼──────┤
│ 权限系统     │   7  │   6  │  10  │   9  │  32  │⭐
├──────────────┼──────┼──────┼──────┼──────┼──────┤
│ 文档存储     │   6  │   8  │   8  │   7  │  29  │
├──────────────┼──────┼──────┼──────┼──────┼──────┤
│ 搜索功能     │   7  │   6  │   5  │   6  │  24  │
├──────────────┼──────┼──────┼──────┼──────┼──────┤
│ 评论系统     │   4  │   4  │   6  │   5  │  19  │
└──────────────┴──────┴──────┴──────┴──────┴──────┘

关键路径识别 (总分 > 30):
✓ 实时协作编辑 - 需要详细设计
✓ 版本控制 - 需要详细设计
✓ 权限系统 - 需要详细设计
```

### 关键路径详细设计内容

```
1. 端到端流程设计
   • 用时序图/流程图描绘完整交互
   • 详细列出每一步操作
   • 考虑各种边界情况
   • 验证模块划分和技术选型

2. 数据模型和算法细节
   • 设计详细的数据结构
   • 确定核心算法逻辑
   • 考虑并发控制机制
   • 预留算法优化空间

3. 性能与容量设计
   • 进行容量预估
   • 识别性能瓶颈
   • 设计缓存策略
   • 规划扩展方案

4. 健壮性与异常处理
   • 识别失败场景
   • 设计补偿机制
   • 实现超时重试
   • 确保幂等性
   • 设计限流熔断

5. 安全和监控设计
   • 嵌入权限校验
   • 数据校验和防注入
   • 埋点日志和指标
   • 设计监控仪表盘
```

### 关键路径详细设计示例

**实时协作编辑详细设计**

```
┌─────────────────────────────────────────────────────┐
│           实时协作编辑完整流程                       │
├─────────────────────────────────────────────────────┤
│                                                     │
│  阶段1: 初始化                                       │
│  ┌─────────────────────────────────────┐          │
│  │ 用户打开文档                         │          │
│  │   ↓                                 │          │
│  │ 建立WebSocket连接                    │          │
│  │   ↓                                 │          │
│  │ 订阅文档变更频道                     │          │
│  │   ↓                                 │          │
│  │ 加载当前文档内容                     │          │
│  └─────────────────────────────────────┘          │
│                                                     │
│  阶段2: 本地编辑                                     │
│  ┌─────────────────────────────────────┐          │
│  │ 用户输入字符                         │          │
│  │   ↓                                 │          │
│  │ 本地立即显示 (乐观更新)              │          │
│  │   ↓                                 │          │
│  │ 生成操作对象 (Operation)             │          │
│  │   {                                 │          │
│  │     type: 'insert',                 │          │
│  │     position: 42,                   │          │
│  │     content: 'hello',               │          │
│  │     user_id: 'alice',               │          │
│  │     timestamp: 1234567890           │          │
│  │   }                                 │          │
│  └─────────────────────────────────────┘          │
│                                                     │
│  阶段3: 发送到服务器                                 │
│  ┌─────────────────────────────────────┐          │
│  │ 通过WebSocket发送操作                │          │
│  │   ↓                                 │          │
│  │ 服务器接收操作                       │          │
│  │   ↓                                 │          │
│  │ 验证操作合法性                       │          │
│  │   ↓                                 │          │
│  │ OT引擎转换操作 (解决冲突)            │          │
│  │   ↓                                 │          │
│  │ 应用操作到服务器状态                 │          │
│  └─────────────────────────────────────┘          │
│                                                     │
│  阶段4: 广播给其他用户                               │
│  ┌─────────────────────────────────────┐          │
│  │ 服务器广播操作                       │          │
│  │   ↓                                 │          │
│  │ 其他在线用户接收                     │          │
│  │   ↓                                 │          │
│  │ 本地OT引擎转换                       │          │
│  │   ↓                                 │          │
│  │ 应用到本地文档                       │          │
│  │   ↓                                 │          │
│  │ 更新UI显示                           │          │
│  └─────────────────────────────────────┘          │
│                                                     │
│  阶段5: 持久化                                       │
│  ┌─────────────────────────────────────┐          │
│  │ 批量累积操作 (100ms窗口)             │          │
│  │   ↓                                 │          │
│  │ 异步写入数据库                       │          │
│  │   ↓                                 │          │
│  │ 创建版本快照 (定期)                  │          │
│  └─────────────────────────────────────┘          │
└─────────────────────────────────────────────────────┘
```

**冲突解决机制**

```
OT算法示例:

初始文档: "Hello World"
          ^     ^
        pos0   pos6

场景: 两个用户同时编辑

User A: 在pos0插入 "Hi "
User B: 在pos6删除 "World"

问题: 如果直接应用，会导致不一致

解决: 操作转换

┌──────────────────────────────────────┐
│  Server State: "Hello World"         │
├──────────────────────────────────────┤
│                                      │
│  收到 Op_A: insert(0, "Hi ")         │
│  应用后: "Hi Hello World"            │
│                                      │
│  收到 Op_B: delete(6, 5)             │
│  需要转换: 因为Op_A已改变文档        │
│  转换后: delete(9, 5)  (位置调整)    │
│  应用后: "Hi Hello "                 │
└──────────────────────────────────────┘

关键: 保证最终一致性
所有客户端最终看到相同内容
```

### 高手心法

```
✓ 聚焦瓶颈优先
  先识别系统性能或复杂度的瓶颈段落
  优先设计优化这些部分
  例: 预估数据库扛不住,就先考虑拆库或加缓存

✓ 逐步深入
  设计是逐层细化的
  先保证逻辑跑通,其次再局部优化
  不可能一开始就把所有细节弄明白

✓ 讲故事法
  要能讲出从输入到输出的清晰"故事"
  将技术方案融入场景描述中
  使设计思路连贯可讲
  方便与他人沟通

✓ 预留余地
  既要全力以赴优化,也要考虑未来变更的余地
  先实现简单算法,但预留策略接口
  未来可以插件式替换更好的算法
  体现对演进的考虑

✓ 可监控性设计
  可监控性是设计的重要组成部分
  不是等系统出了故障再打补丁
  在设计阶段就嵌入监控能力
```

### 性能预算

```
Google Docs 性能预算计算

┌─────────────────────────────────────────┐
│          业务指标                        │
├─────────────────────────────────────────┤
│ 日活用户: 1000万                         │
│ 峰值并发: 100万                          │
│ 平均文档大小: 50KB                       │
│ 同时编辑人数: 平均5人，峰值100人         │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│          服务器需求                      │
├─────────────────────────────────────────┤
│ WebSocket服务器:                         │
│ - 单机支持: 10000连接                    │
│ - 需要服务器: 100台                      │
│ - 冗余(50%): 150台                       │
│                                         │
│ 应用服务器:                              │
│ - 单机QPS: 5000                          │
│ - 峰值QPS: 50000                         │
│ - 需要服务器: 10台                       │
│ - 冗余: 15台                             │
│                                         │
│ 数据库:                                  │
│ - PostgreSQL主库: 2台                    │
│ - 只读副本: 8台                          │
│ - 总计: 10台                             │
│                                         │
│ Redis缓存:                               │
│ - 集群节点: 6台                          │
│                                         │
│ 总成本估算:                              │
│ - 服务器: 150 + 15 + 10 + 6 = 181台     │
│ - 月成本: ~50万人民币                    │
└─────────────────────────────────────────┘
```

### 安全和稳定性设计

```
┌─────────────────────────────────────────┐
│          安全设计矩阵                    │
├─────────────────────────────────────────┤
│                                         │
│  1. 认证 (Authentication)               │
│     ┌─────────────────────┐            │
│     │ OAuth 2.0           │            │
│     │ JWT Token           │            │
│     │ 多因素认证 (2FA)    │            │
│     └─────────────────────┘            │
│                                         │
│  2. 授权 (Authorization)                │
│     ┌─────────────────────┐            │
│     │ RBAC权限模型        │            │
│     │ 细粒度权限控制      │            │
│     │ 每次操作验证        │            │
│     └─────────────────────┘            │
│                                         │
│  3. 数据加密                            │
│     ┌─────────────────────┐            │
│     │ 传输: TLS 1.3       │            │
│     │ 存储: AES-256       │            │
│     │ 敏感字段: 单独加密  │            │
│     └─────────────────────┘            │
│                                         │
│  4. 审计日志                            │
│     ┌─────────────────────┐            │
│     │ 记录所有操作        │            │
│     │ 包含用户/时间/内容  │            │
│     │ 不可篡改            │            │
│     └─────────────────────┘            │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│          稳定性保障                      │
├─────────────────────────────────────────┤
│                                         │
│  1. 降级策略                            │
│     正常: 实时协作                      │
│       ↓ 服务器压力大                    │
│     降级1: 延迟同步 (5秒)               │
│       ↓ 继续恶化                        │
│     降级2: 只读模式                     │
│       ↓ 极端情况                        │
│     降级3: 离线编辑                     │
│                                         │
│  2. 限流保护                            │
│     ┌─────────────────────┐            │
│     │ API限流: 100次/分钟 │            │
│     │ WebSocket: 每用户1个│            │
│     │ 上传: 10MB/次       │            │
│     └─────────────────────┘            │
│                                         │
│  3. 熔断机制                            │
│     ┌─────────────────────┐            │
│     │ 错误率 > 50%        │            │
│     │   ↓                 │            │
│     │ 开启熔断            │            │
│     │   ↓                 │            │
│     │ 返回缓存/降级服务   │            │
│     │   ↓                 │            │
│     │ 30秒后尝试恢复      │            │
│     └─────────────────────┘            │
│                                         │
│  4. 数据备份                            │
│     ┌─────────────────────┐            │
│     │ 实时备份 (主从同步) │            │
│     │ 每日全量备份        │            │
│     │ 每周异地备份        │            │
│     │ 保留30天            │            │
│     └─────────────────────┘            │
└─────────────────────────────────────────┘
```

---

## 阶段六:可演进性设计

### 目标
**从长远角度审视设计,确保系统具备良好的扩展演进能力,能够适应未来的变化和增长**

### 核心理念

```
优秀的设计不仅解决眼前问题,还为未来留下余地。

软件生命周期中变化是常态:
• 需求会变化
• 用户会增长
• 技术会更新

可演进性思考 = 给设计做"展望未来"的Review
```

### 可演进性检查清单

#### 1. 水平扩展与伸缩性

```
关键问题:
• 系统未来的规模增长如何?
• 设计如何平滑扩展以支撑更大负载?
• 下一个数量级的增长,我们准备好了吗?

检查项:
□ 模块是否容易水平扩展?
  • 无状态服务可以直接增加实例
  • 有状态服务有分片方案

□ 数据库面临更大数据量时?
  • 能否方便地分库分表
  • 索引设计是否支持大数据量
  • 读写分离方案是否就绪

□ 是否选择了可分布式扩展的组件?
  • 缓存集群
  • 消息队列
  • 负载均衡

示例:
目前支持: 100万日活用户
增长到:   1000万日活用户
需要改变:
  • WebSocket服务器从15台扩展到150台
  • 数据库从主从变为分片集群
  • 增加CDN节点覆盖更多地区
```

#### 2. 模块解耦与可替换性

```
关键问题:
• 未来可能更换哪些模块的实现?
• 更换某一部分时是否需要推倒重来?
• 新需求能否无痛添加?

检查项:
□ 模块间接口是否稳定且通用?
  • 内部实现变化不影响外部契约
  • 使用抽象接口而非具体实现

□ 模块职责边界是否清晰?
  • 单一职责原则
  • 高内聚低耦合

□ 是否支持插件化扩展?
  • 策略模式支持算法替换
  • 工厂模式支持实现切换

示例场景:
• 将推荐算法从规则改成AI模型
  → 推荐模块是否可独立替换?
  
• 增加新业务模块(如增加直播功能)
  → 当前架构能否无痛添加?
  
• 更换存储引擎(从MySQL到PostgreSQL)
  → 数据访问层是否充分抽象?
```

#### 3. 设计简洁性与复杂度控制

```
关键问题:
• 我们是不是over-engineer了?
• 是否加入了很多目前不需要的"灵活点"?
• 如何在演进性和简洁性之间平衡?

检查项:
□ 遵循KISS原则
  Keep It Simple, Stupid
  在满足已知需求的前提下尽可能简单

□ 避免过度设计
  • 不为所有可能的变化做详尽设计
  • 不人为增加不必要的抽象层

□ 遵循YAGNI原则
  You Aren't Gonna Need It
  不实现当前不需要的功能

□ 适度的延展
  • 为已知的近期变化预留扩展点
  • 对远期不确定的变化保持简单

平衡之道:
  理想的演进性 = 适度的延展性
  ≠ 一开始就为所有可能的变化做钜细无遗的设计
  
  架构首先服务当前业务
  不能为了抽象而抽象
```

#### 4. 容错与降级能力

```
关键问题:
• 更恶劣情况下系统如何表现?
• 单点故障是否清除?
• 模块宕机时系统能否降级运行?

检查项:
□ 消除单点故障
  • 关键服务多实例部署
  • 数据库主从/集群
  • 避免共享资源成为瓶颈

□ 设计降级策略
  正常:    实时协作
    ↓ 压力大
  降级1:   延迟同步(5秒)
    ↓ 继续恶化
  降级2:   只读模式
    ↓ 极端情况
  降级3:   离线编辑

□ 实现熔断机制
  • 错误率超过阈值时开启熔断
  • 返回缓存或降级服务
  • 定期尝试恢复

□ 灾难恢复方案
  • 数据备份策略
  • 异地多活架构
  • 灾难恢复演练

示例:
短视频评论服务宕机:
  → 视频观看仍可继续
  → 临时隐藏评论功能
  → 核心功能不受影响
```

#### 5. 运维与升级能力

```
关键问题:
• 系统如何发布升级?
• 配置如何调整?
• 是否支持平滑升级?

检查项:
□ 支持灰度发布
  • 逐步升级新版本
  • 出问题可快速回滚
  • 不中断业务

□ 配置集中管理
  • 配置与代码分离
  • 动态配置更新
  • 配置版本管理

□ 监控和告警
  • 关键指标实时监控
  • 异常自动告警
  • 可视化运维面板

□ 日志和审计
  • 结构化日志
  • 分布式追踪
  • 操作审计记录

□ 持续交付能力
  • 自动化测试
  • CI/CD流水线
  • 自动化部署

DevOps理念:
  在架构设计时就要布置运维能力
  使系统能持续交付和演进而不中断业务
```

### 演进性评估矩阵

```
┌──────────────┬────────┬────────┬────────┬────────┐
│ 评估维度     │ 差     │ 一般   │ 良好   │ 优秀   │
├──────────────┼────────┼────────┼────────┼────────┤
│ 水平扩展性   │ 难扩展 │ 需重构 │ 可扩展 │ 弹性强 │
├──────────────┼────────┼────────┼────────┼────────┤
│ 模块可替换性 │ 强耦合 │ 部分解耦│ 接口抽象│ 插件化 │
├──────────────┼────────┼────────┼────────┼────────┤
│ 设计简洁度   │ 过度复杂│ 略复杂 │ 恰当   │ 简洁优雅│
├──────────────┼────────┼────────┼────────┼────────┤
│ 容错降级能力 │ 无容错 │ 部分容错│ 可降级 │ 自愈能力│
├──────────────┼────────┼────────┼────────┼────────┤
│ 运维升级能力 │ 停机升级│ 需维护窗口│灰度发布│零停机 │
└──────────────┴────────┴────────┴────────┴────────┘

目标: 至少达到"良好"级别
关键路径相关模块: 应达到"优秀"级别
```

### 高手心法

```
✓ 为未来留余地,但不过度设计
  平衡当前需求和未来演进
  
✓ 优先考虑已知的变化方向
  而非所有可能的变化
  
✓ 保持架构的演进能力
  比一开始就完美更重要
  
✓ 定期Review架构健康度
  技术债要及时偿还
  
✓ 拥抱变化,但控制变化
  通过模块化和抽象管理变化的影响范围

演进策略:
  • 先简单实现,再逐步优化
  • 在痛点处投入重构
  • 保持持续小步迭代
  • 避免大爆炸式重写

架构师自问:
  "这个设计6个月后还合适吗?"
  "如果用户增长10倍怎么办?"
  "如果要替换这个组件需要多大代价?"
  "系统的技术债务在哪里?"
```

### 演进性设计检查清单

```
□ 水平扩展性
  □ 无状态设计
  □ 分布式友好
  □ 容量规划完成

□ 模块可替换性
  □ 接口稳定
  □ 依赖抽象
  □ 职责清晰

□ 简洁性
  □ 遵循KISS
  □ 遵循YAGNI
  □ 避免过度设计

□ 容错能力
  □ 无单点故障
  □ 降级策略
  □ 熔断机制
  □ 备份方案

□ 运维能力
  □ 灰度发布
  □ 监控告警
  □ 日志审计
  □ 配置管理
```

---

## 设计方法论总结

### 核心设计原则

```
1. 分而治之 (Divide and Conquer)
   大问题 → 小问题 → 更小的问题
   
2. 关注点分离 (Separation of Concerns)
   每个模块只关注一件事
   
3. 高内聚低耦合 (High Cohesion, Low Coupling)
   模块内部紧密，模块之间松散
   
4. 依赖倒置 (Dependency Inversion)
   依赖抽象，不依赖具体实现
   
5. 渐进式设计 (Progressive Design)
   先简单实现，再逐步优化
```

### 设计流程图

```
┌──────────────────────────────────────────────────┐
│                  设计决策树                       │
├──────────────────────────────────────────────────┤
│                                                  │
│  开始新项目                                       │
│      │                                           │
│      ├─► 需求分析                                │
│      │    - 收集功能需求                          │
│      │    - 识别非功能需求                        │
│      │    - 编写Use Case                         │
│      │                                           │
│      ├─► 概念建模                                │
│      │    - 识别核心概念                          │
│      │    - 定义概念职责                          │
│      │    - 建立概念关系                          │
│      │                                           │
│      ├─► 模块拆解                                │
│      │    - 按业务能力划分                        │
│      │    - 定义模块边界                          │
│      │    - 设计模块接口                          │
│      │                                           │
│      ├─► 技术选型                                │
│      │    - 选择数据库                            │
│      │    - 选择缓存方案                          │
│      │    - 选择通信方式                          │
│      │                                           │
│      ├─► 关键路径设计                            │
│      │    - 识别关键模块                          │
│      │    - 详细设计流程                          │
│      │    - 性能优化方案                          │
│      │                                           │
│      └─► 实施和迭代                              │
│           - MVP实现                              │
│           - 性能测试                              │
│           - 持续优化                              │
└──────────────────────────────────────────────────┘
```

### 常见陷阱和解决方案

```
┌─────────────────┬──────────────────┬──────────────────┐
│ 陷阱            │ 表现             │ 解决方案         │
├─────────────────┼──────────────────┼──────────────────┤
│ 过度设计        │ 复杂度远超需求   │ MVP原则          │
│                 │ 大量未用代码     │ YAGNI原则        │
├─────────────────┼──────────────────┼──────────────────┤
│ 过早优化        │ 为未发生的性能   │ 先保证正确性     │
│                 │ 问题优化         │ 测量后再优化     │
├─────────────────┼──────────────────┼──────────────────┤
│ 耦合过紧        │ 改一处影响全局   │ 依赖抽象接口     │
│                 │ 难以测试         │ 保持模块独立     │
├─────────────────┼──────────────────┼──────────────────┤
│ 职责不清        │ 一个类做太多事   │ 单一职责原则     │
│                 │ 难以理解         │ 明确边界         │
├─────────────────┼──────────────────┼──────────────────┤
│ 忽略非功能需求  │ 性能差           │ 提前考虑         │
│                 │ 不可扩展         │ 预留优化空间     │
└─────────────────┴──────────────────┴──────────────────┘
```

### 设计检查清单

```
✓ 需求阶段
  □ 功能需求明确
  □ Use Case完整
  □ 非功能需求量化
  □ 用户场景清晰
  □ 优先级已确定
  □ 边界和约束明确

✓ 概念建模阶段
  □ 核心概念识别完整
  □ 概念职责清晰
  □ 概念关系合理
  □ 用Use Case验证通过
  □ 使用业务语言
  □ 避免过度抽象

✓ 模块拆解阶段
  □ 模块划分合理
  □ 模块职责单一
  □ 模块边界清晰
  □ 依赖关系简单
  □ 接口定义明确
  □ 关键数据流清晰

✓ 技术选型阶段
  □ 技术选型有理有据
  □ 考虑了扩展性
  □ 考虑了性能
  □ 考虑了成本
  □ 符合团队能力
  □ 满足非功能需求

✓ 关键路径设计阶段
  □ 识别了关键模块
  □ 详细设计完整
  □ 性能预算合理
  □ 安全稳定性考虑周全
  □ 异常处理完善
  □ 监控能力就绪

✓ 可演进性设计阶段
  □ 水平扩展性良好
  □ 模块可替换
  □ 设计保持简洁
  □ 容错降级能力
  □ 运维升级友好
  □ 技术债务可控
```

---

## 快速参考表

### 设计阶段对照表

```
┌────────┬────────────┬────────────┬────────────┬────────────┐
│ 阶段   │ 关键问题   │ 主要产物   │ 关注点     │ 思维工具   │
├────────┼────────────┼────────────┼────────────┼────────────┤
│ 需求   │ 要做什么？ │ Use Case   │ 理解问题   │ 问题空间   │
│ 分析   │ 为什么做？ │ 需求文档   │ 用户价值   │ 思维       │
├────────┼────────────┼────────────┼────────────┼────────────┤
│ 概念   │ 核心概念？ │ 领域模型   │ 业务理解   │ 抽象化     │
│ 建模   │ 如何关联？ │ 概念关系图 │ 统一语言   │ 思维       │
├────────┼────────────┼────────────┼────────────┼────────────┤
│ 模块   │ 如何组织？ │ 架构图     │ 整体结构   │ 模块化     │
│ 拆解   │ 边界在哪？ │ 模块说明   │ 职责划分   │ 思维       │
├────────┼────────────┼────────────┼────────────┼────────────┤
│ 技术   │ 用什么？   │ 技术方案   │ 实现细节   │ 权衡       │
│ 选型   │ 怎么实现？ │ 接口设计   │ 技术决策   │ 思维       │
├────────┼────────────┼────────────┼────────────┼────────────┤
│ 关键   │ 难点在哪？ │ 详细设计   │ 攻坚克难   │ 深度       │
│ 路径   │ 如何解决？ │ 性能方案   │ 风险控制   │ 思维       │
├────────┼────────────┼────────────┼────────────┼────────────┤
│ 可演进 │ 如何变化？ │ 演进方案   │ 着眼未来   │ 动态化     │
│ 设计   │ 如何扩展？ │ 升级策略   │ 弹性伸缩   │ 思维       │
└────────┴────────────┴────────────┴────────────┴────────────┘
```

### 常用设计模式速查

```
┌──────────────┬─────────────────┬─────────────────┐
│ 模式         │ 适用场景        │ Google Docs应用 │
├──────────────┼─────────────────┼─────────────────┤
│ 观察者模式   │ 事件通知        │ 实时协作同步    │
├──────────────┼─────────────────┼─────────────────┤
│ 策略模式     │ 算法切换        │ OT算法实现      │
├──────────────┼─────────────────┼─────────────────┤
│ 工厂模式     │ 对象创建        │ 创建不同文档类型│
├──────────────┼─────────────────┼─────────────────┤
│ 单例模式     │ 全局唯一对象    │ 配置管理器      │
├──────────────┼─────────────────┼─────────────────┤
│ 责任链模式   │ 请求处理链      │ 权限验证链      │
├──────────────┼─────────────────┼─────────────────┤
│ 装饰器模式   │ 动态增强功能    │ 文档权限包装    │
└──────────────┴─────────────────┴─────────────────┘
```

---

## 结语

```
设计的本质:
- 不是追求完美
- 而是管理复杂度
- 在约束下做最优选择

设计的艺术:
- 知道什么时候详细设计
- 知道什么时候简单实现
- 知道什么时候重构优化

记住:
"任何傻瓜都能写出计算机能理解的代码，
 优秀的程序员写出人能理解的代码。"
 
                    —— Martin Fowler
```

---

**使用建议:**

1. 每次设计新系统前，先走一遍六个阶段
2. 识别关键路径，重点投入时间
3. 保持设计文档更新
4. 定期回顾和重构
5. 与团队保持设计共识
6. 定期评估系统的可演进性

祝你设计出优秀的系统！🎯

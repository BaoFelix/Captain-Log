# 🏗️ 面向对象设计完整指南

> **核心理念：高内聚 + 低耦合 = 可扩展、可测试、可维护**

---

## 🔖 快速导航目录

> **提示**：VS Code中按 `Ctrl+点击`（Windows）或 `Cmd+点击`（Mac）可直接跳转

### 核心章节
- [第一部分：三步设计流程（战略层）](#-第一部分三步设计流程战略层)
- [第二部分：依赖控制金字塔（战术层）](#️-第二部分依赖控制金字塔战术层)
- [第三部分：架构模式（实施层）](#️-第三部分架构模式实施层)
- [第四部分：11个最实用设计模式](#-第四部分11个最实用的设计模式)
- [第五部分：质量保障与持续改进](#-第五部分质量保障与持续改进)

### 设计流程
- [Step 1: 划分领域边界](#step-1-划分领域边界--分而治之)
  - [事件风暴识别业务事件](#实践技巧)
  - [按变化原因组织目录](#实践技巧)
  - [纯算法与基础设施分离](#实践技巧)
  - [稳定性分层思维](#实践技巧)
- [Step 2: 定义职责与契约](#step-2-定义职责与契约--模块关系与接口设计)
  - [单一职责原则详解](#三大核心原则)
  - [接口隔离原则详解](#三大核心原则)
  - [依赖倒置原则详解](#三大核心原则)
  - [Orchestrator模式（编排者）](#orchestrator模式编排者模式)
- [Step 3: 逐层细化](#step-3-逐层细化--模块内部设计迭代)

### 依赖与原则
- [依赖金字塔六层级](#依赖关系六层级从弱到强)
  - [Lv-0: 依赖（最弱）](#lv-0-依赖-dependency---最弱-)
  - [Lv-1: 关联](#lv-1-关联-association---弱耦合-)
  - [Lv-2: 实现（推荐）](#lv-2-实现-realization---推荐-)
  - [Lv-3: 聚合](#lv-3-聚合-aggregation---集合关系-)
  - [Lv-4: 组合](#lv-4-组合-composition---强耦合-)
  - [Lv-5: 继承（最强）](#lv-5-继承-inheritance---最强-)
  - [跨边界依赖规则总结](#跨边界依赖规则总结)
- [SOLID五大原则](#solid五大原则完整解析)
  - [S - 单一职责原则](#1-单一职责原则-srp-详解)
    - [职责数量指导](#职责数量指导)
    - [SRP在嵌套职责中的应用](#srp在嵌套职责中的应用)
  - [O - 开放-封闭原则](#2-开放-封闭原则-ocp-详解)
  - [L - 里氏替换原则](#3-里氏替换原则-lsp-详解)
  - [I - 接口隔离原则](#4-接口隔离原则-isp-详解)
  - [D - 依赖倒置原则](#5-依赖倒置原则-dip-深度解析)
    - [跨模块接口位置策略](#跨模块接口位置策略)
- [8项黄金法则](#8项黄金法则总结)
  - [6. 信息隐藏（封装）](#6-信息隐藏封装)
  - [7. 优先组合而非继承](#7-优先组合而非继承)
    - [跨边界继承禁令](#跨边界继承禁令)
  - [8. 资源所有权管理](#8-资源所有权管理c特有)

### 架构模式
- [分层架构](#1-分层架构layered-architecture)
- [六边形架构](#2-六边形架构hexagonal--ports--adapters)
- [事件驱动架构](#3-事件驱动架构event-driven-architecture)

### 设计模式速查（11个）
- [Strategy 策略模式](#1-strategy-策略模式)
- [Observer 观察者模式](#2-observer-观察者模式)
- [Factory 工厂模式](#3-factory-method-工厂方法)
- [Builder 建造者模式](#4-builder-建造者模式)
- [Singleton 单例模式](#5-singleton-单例模式)
- [Adapter 适配器模式](#6-adapter-适配器模式)
- [Decorator 装饰者模式](#7-decorator-装饰者模式)
- [Proxy 代理模式](#8-proxy-代理模式)
- [Flyweight 享元模式](#9-flyweight-享元模式)
- [Command 命令模式](#10-command-命令模式)
- [Template Method 模板方法](#11-template-method-模板方法)

### 实用工具
- [设计检查表](#设计检查表)
- [核心概念速查表](#核心概念速查表)
- [问题→模式映射表](#问题--模式映射表)

---

## 📋 全文导览地图

```
┌─────────────────────────────────────────────────────────────┐
│                    统一的设计思维                            │
│         从系统架构到代码细节，应用相同的原则                 │
└──────────────────┬──────────────────────────────────────────┘
                   ↓
    ┌──────────────────────────────────────────┐
    │ 第一部分：三步设计流程（战略层）         │
    │   Step 1: 划分领域边界                   │
    │   Step 2: 定义职责与契约                 │
    │   Step 3: 逐层细化设计                   │
    └──────────────┬───────────────────────────┘
                   ↓
    ┌──────────────────────────────────────────┐
    │ 第二部分：依赖控制金字塔（战术层）       │
    │   六层级依赖关系 (Lv-0 → Lv-5)          │
    │   SOLID + 8项黄金法则                    │
    └──────────────┬───────────────────────────┘
                   ↓
    ┌──────────────────────────────────────────┐
    │ 第三部分：架构模式（实施层）             │
    │   分层架构 / 六边形架构 / 事件驱动       │
    └──────────────┬───────────────────────────┘
                   ↓
    ┌──────────────────────────────────────────┐
    │ 第四部分：设计模式（工具箱）             │
    │   9个最实用的GoF模式                     │
    └──────────────┬───────────────────────────┘
                   ↓
    ┌──────────────────────────────────────────┐
    │ 第五部分：质量保障（持续改进）           │
    │   并发设计 / 测试策略 / 设计检查表       │
    └──────────────────────────────────────────┘
```

---

## 🎯 第一部分：三步设计流程（战略层）

### 核心理念可视化

```
┌─────────────────────────────────────────────────────────────┐
│                    高内聚 vs 低耦合                          │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  高内聚（Cohesion）                                          │
│  ├─ 定义：模块内部元素紧密相关，专注单一职责                 │
│  ├─ 好处：易理解、易测试、易维护                             │
│  ├─ 示例：UserService 只负责用户业务逻辑                     │
│  └─ 反例：一个类既处理UI又处理数据库又做计算                 │
│                                                              │
│  低耦合（Coupling）                                          │
│  ├─ 定义：模块间依赖最小化，可独立修改                       │
│  ├─ 好处：易扩展、易替换、变化隔离                           │
│  ├─ 示例：通过接口依赖，而非具体实现                         │
│  └─ 反例：A直接创建B的实例，修改B影响A                       │
│                                                              │
│  设计目标：                                                   │
│  ✓ 扩展性强    ✓ 可测试     ✓ 易演化                        │
│  ✓ 并发友好    ✓ 可维护     ✓ 模块独立                      │
│                                                              │
└─────────────────────────────────────────────────────────────┘

耦合的本质 = 系统为了让两个模块协同而被迫泄漏的"自由度"
  高耦合 = "绑在一起，动一个影响一片" ❌
  低耦合 = "插拔式设计，各司其职互不干扰" ✓
```

---

### Step 1: 划分领域边界 – "分而治之"

```
┌─────────────────────────────────────────────────────────────┐
│              领域拆分策略（DDD思想）                          │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  大系统（电商平台）                                           │
│     ↓                                                        │
│  ┌──────────┬──────────┬──────────┬──────────┐            │
│  │  子域1   │  子域2   │  子域3   │  子域4   │  ← 限界上下文│
│  │ (用户)   │ (订单)   │ (支付)   │ (库存)   │             │
│  └──────────┴──────────┴──────────┴──────────┘            │
│     ↓           ↓           ↓           ↓                    │
│  微服务A    微服务B    微服务C    微服务D     ← 服务边界      │
│  User       Order      Payment    Inventory                 │
│  Service    Service    Service    Service                   │
│     ↓           ↓           ↓           ↓                    │
│  内部模块   内部模块   内部模块   内部模块   ← 模块划分      │
│  细分        细分        细分        细分                     │
│                                                              │
└─────────────────────────────────────────────────────────────┘

拆分的四大依据：
├─ 🎯 业务能力：按业务功能/流程划分
│    └─ 例：用户管理、订单处理、支付流程各自独立
│
├─ ⏱️ 变化频率：易变与稳定分离
│    └─ 例：促销规则(易变) vs 核心订单逻辑(稳定)
│
├─ 🔄 生命周期：不同生命周期分离
│    └─ 例：短命的缓存对象 vs 持久化的用户对象
│
└─ 🛠️ 技术依赖：算法逻辑 vs 基础设施
     └─ 例：定价算法(纯逻辑) vs 数据库访问(基础设施)

关键原则：
✓ 先定义边界，后定义关系
✓ 服务内高内聚，服务间低耦合
✓ 每个模块承担1-2个核心职责
✗ 避免在错误层次使用继承/组合
✗ 避免"上帝模块"（一个模块做所有事）
```

**实践技巧：**
- ✅ 使用**事件风暴**识别业务事件和实体
  ```
  事件风暴工作坊流程：
  1. 识别领域事件（橙色便签）："订单已创建"、"支付已完成"
  2. 找触发命令（蓝色便签）："创建订单" → "订单已创建"
  3. 识别聚合/实体（黄色便签）：Order、Payment
  4. 划分界限上下文：相关事件聚集成子域
  
  优势：发现隐藏业务流程、识别领域边界、团队达成共识
  ```

- ✅ 按**变化原因**组织目录结构
  ```
  含义：将"因相同原因而改变的代码"放在一起
  
  ❌ 按技术分层：
  /controllers, /services, /repositories
  问题：修改用户功能需要跨多个目录
  
  ✅ 按业务领域：
  /user-domain, /order-domain, /payment-domain
  优势：修改用户功能只在user-domain目录
  
  判断方法：问"这段代码可能因为什么原因修改？"
  - 业务规则变化 → 放在domain层
  - 技术实现变化 → 放在infrastructure层
  - UI交互变化 → 放在presentation层
  ```

- ✅ 将**纯算法**与**基础设施**分离
  ```
  纯算法 = 业务规则 = 核心价值
    特征：无副作用、可预测、易测试、可移植
    示例：折扣计算、定价规则、验证逻辑
  
  基础设施 = 技术实现 = 可替换部件
    特征：有副作用、可能失败、需要Mock、环境依赖
    示例：数据库、文件、网络、框架调用
  
  分离方法：
  1. 提取纯函数（相同输入→相同输出）
  2. 通过接口隔离基础设施
  3. 编排层协调两者
  
  好处：算法可独立演化、技术栈可替换、测试覆盖率提升
  ```

- ✅ **稳定性分层**：纯逻辑 → 接口 → 编排 → 实现
  ```
  稳定性金字塔（从稳定到易变）：
  
       📐 纯算法/业务逻辑 (最稳定)
      ───────────────────────────
     📋 接口/抽象契约 (稳定)
    ─────────────────────────────
   🎭 编排层 (中等稳定)
  ───────────────────────────────
 🔌 实现层 (易变)
─────────────────────────────────
🏗️ 基础设施 (最易变)
  
  依赖方向：易变 ──→ 接口 ←── 稳定
           (实现)    ↑      (算法)
                  由中层编排
  
  核心原则：让不稳定的依赖稳定的，而非反过来
  ```

- ✅ 单个源文件不超过500行（建议）

**反模式警告：**
```
❌ 按技术分层组织业务代码
   /controllers  (所有控制器)
   /services     (所有服务)
   /models       (所有模型)
   → 同一业务逻辑散落各处

✅ 按业务领域组织代码
   /user-domain     (用户相关一切)
   /order-domain    (订单相关一切)
   /payment-domain  (支付相关一切)
   → 高内聚，易维护
```

---

### Step 2: 定义职责与契约 – 模块关系与接口设计

```
┌─────────────────────────────────────────────────────────────┐
│                  模块协作的核心机制                           │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌────────────┐       接口/契约       ┌────────────┐        │
│  │  模块 A    │◄──────────────────────│  模块 B    │        │
│  │ (高层)     │   依赖抽象，非实现     │ (底层)     │        │
│  └────────────┘                       └────────────┘        │
│       │                                     ▲                │
│       │ 依赖                                │ 实现           │
│       ↓                                     │                │
│  ┌──────────────────────────────────────────┐               │
│  │      抽象接口 (Interface/Abstract)       │               │
│  │  - 定义契约（做什么）                     │               │
│  │  - 隐藏实现（怎么做）                     │               │
│  └──────────────────────────────────────────┘               │
│                                                              │
│  依赖方向：高层 → 抽象 ← 底层                                │
│  稳定性：  不稳定 → 稳定 ← 不稳定                            │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

#### 三大核心原则

**1. 单一职责原则（SRP）**

**职责数量指导：**
```
┌─────────────────────────────────────────────────────────────┐
│              职责数量经验法则                                 │
├──────────────┬──────────────┬───────────────────────────────┤
│  层级        │  理想职责数  │  警戒线                       │
├──────────────┼──────────────┼───────────────────────────────┤
│  类 (Class)  │  1个核心职责 │  超过2个 → 考虑拆分            │
│              │              │  超过3个 → 必须拆分            │
├──────────────┼──────────────┼───────────────────────────────┤
│  模块/文件夹 │  1-2个核心   │  超过5个 → 考虑拆分子模块      │
│  (Module)    │  业务领域    │  超过10个 → 必须拆分           │
└──────────────┴──────────────┴───────────────────────────────┘

判断方法：
1. 一句话测试：能用一句话清晰描述职责吗？
2. 变化原因分析：这个类可能因为几个原因被修改？
3. 方法分组：方法是否明显分成几组？
4. 团队职责：是否由多个人因不同原因修改？

特殊情况（可以有多个职责）：
- 聚合根（DDD）：所有职责围绕同一核心概念
- Facade模式：协调多个子系统
- Orchestrator：编排流程（但具体执行委托给其他类）
- Utility类：无状态的纯函数集合
```
```cpp
// ❌ 违反SRP：一个类做太多事
class UserManager {
    void createUser();      // 用户创建
    void sendEmail();       // 邮件发送
    void logActivity();     // 日志记录
    void validateInput();   // 数据验证
};

// ✅ 遵循SRP：每个类一个职责
class UserService {
    void createUser();      // 只负责用户业务
};
class EmailService {
    void sendEmail();       // 只负责邮件
};
class Logger {
    void log();             // 只负责日志
};
class Validator {
    bool validate();        // 只负责验证
};
```

**2. 接口隔离原则（ISP）**
```cpp
// ❌ 违反ISP：庞大的"上帝接口"
class IWorker {
    virtual void work() = 0;
    virtual void eat() = 0;
    virtual void sleep() = 0;
    virtual void play() = 0;
};
// 问题：机器人Worker不需要eat/sleep

// ✅ 遵循ISP：小而精的接口
class IWorkable {
    virtual void work() = 0;
};
class IFeedable {
    virtual void eat() = 0;
};
class HumanWorker : public IWorkable, public IFeedable {
    // 人类需要工作和吃饭
};
class RobotWorker : public IWorkable {
    // 机器人只需要工作
};
```

**封装（Encapsulation）详解：**

```
┌─────────────────────────────────────────────────────────────┐
│                  封装的本质                                   │
├─────────────────────────────────────────────────────────────┤
│  封装 = 信息隐藏 + 访问控制                                   │
│                                                              │
│  目的：                                                       │
│  1. 隐藏实现细节（How）                                      │
│  2. 只暴露必要接口（What）                                    │
│  3. 保护内部状态不被破坏                                      │
│  4. 降低外部对内部的依赖                                      │
│                                                              │
│  三个层次：                                                   │
│  层次1：数据封装（隐藏数据成员，提供getter/setter）          │
│  层次2：行为封装（隐藏算法细节，暴露简洁接口）                │
│  层次3：实现封装（Pimpl，隐藏所有私有成员）                   │
│                                                              │
│  核心价值：                                                   │
│  ✓ 降低复杂性（外部只看接口）                                │
│  ✓ 提高可维护性（修改内部不影响外部）                        │
│  ✓ 保证数据安全（防止非法修改）                              │
│  ✓ 支持演化（内部优化对外透明）                              │
│                                                              │
│  记住：接口 = 承诺（公开的契约）                              │
│        封装 = 自由（隐藏的实现）                              │
└─────────────────────────────────────────────────────────────┘
```

```cpp
// 示例：良好封装的类
class BankAccount {
private:
    double balance_;  // 隐藏数据
    std::vector<Transaction> history_;  // 隐藏内部表示
    
    void logTransaction(const Transaction& trans) {  // 私有辅助方法
        history_.push_back(trans);
    }
    
public:
    void deposit(double amount) {  // 简洁接口
        if (amount <= 0) throw std::invalid_argument("Amount must be positive");
        balance_ += amount;
        logTransaction(Transaction::Deposit(amount));
    }
    
    void withdraw(double amount) {
        if (amount <= 0) throw std::invalid_argument("Amount must be positive");
        if (balance_ < amount) throw std::runtime_error("Insufficient funds");
        balance_ -= amount;
        logTransaction(Transaction::Withdrawal(amount));
    }
    
    double getBalance() const { return balance_; }  // 只读访问
    
    // ✓ 所有余额变化都经过验证和记录
    // ✓ 内部表示可随时修改（如改用分存储）
    // ✓ 外部无法破坏账户一致性
};
```

**3. 依赖倒置原则（DIP）**
```
┌──────────────────────────────────────────────────────────┐
│              依赖倒置的本质                               │
├──────────────────────────────────────────────────────────┤
│  传统依赖（高层依赖低层）❌                               │
│  ┌─────────────┐                                         │
│  │ UserService │ ──────→ ┌──────────────┐               │
│  │  (高层)     │         │ MySQLDatabase│               │
│  └─────────────┘         │  (低层实现)  │               │
│                          └──────────────┘               │
│  问题：换数据库需修改UserService                          │
│                                                          │
│  依赖倒置（都依赖抽象）✓                                  │
│  ┌─────────────┐                                         │
│  │ UserService │                                         │
│  │  (高层)     │                                         │
│  └──────┬──────┘                                         │
│         │ 依赖                                           │
│         ↓                                                │
│  ┌─────────────┐                                         │
│  │ IDatabase   │  ← 抽象接口（最稳定）                    │
│  └──────▲──────┘                                         │
│         │ 实现                                           │
│         │                                                │
│  ┌──────┴──────────┬────────────┐                       │
│  │ MySQLDatabase   │ PostgreSQL │                       │
│  │   (实现1)       │  (实现2)   │                       │
│  └─────────────────┴────────────┘                       │
│                                                          │
│  好处：换数据库无需修改UserService                        │
└──────────────────────────────────────────────────────────┘
```

**DIP代码示例：**
```cpp
// 抽象接口（稳定）
class IDatabase {
public:
    virtual ~IDatabase() = default;
    virtual void connect() = 0;
    virtual User getUserById(int id) = 0;
};

// 高层业务逻辑（依赖抽象）
class UserService {
    IDatabase* database;  // 依赖接口
public:
    UserService(IDatabase* db) : database(db) {}  // 依赖注入
    
    User getUser(int id) {
        database->connect();
        return database->getUserById(id);
    }
};

// 低层实现1（实现接口）
class MySQLDatabase : public IDatabase {
    void connect() override { /* MySQL连接 */ }
    User getUserById(int id) override { /* MySQL查询 */ }
};

// 低层实现2（实现接口）
class PostgreSQLDatabase : public IDatabase {
    void connect() override { /* PostgreSQL连接 */ }
    User getUserById(int id) override { /* PostgreSQL查询 */ }
};

// 使用：运行时注入
MySQLDatabase mysql;
UserService service(&mysql);  // 可随时替换为PostgreSQL

// 测试：注入Mock
class MockDatabase : public IDatabase { /* ... */ };
MockDatabase mockDb;
UserService testService(&mockDb);  // 测试中隔离真实数据库
```

---

#### Orchestrator模式（编排者模式）

```
┌─────────────────────────────────────────────────────────────┐
│              编排者 vs 执行者                                 │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│                  ┌──────────────────┐                       │
│                  │  Orchestrator    │  ← 编排者              │
│                  │  (协调流程)      │                        │
│                  └────────┬─────────┘                       │
│                           │                                  │
│          ┌────────────────┼────────────────┐                │
│          │                │                │                │
│          ↓                ↓                ↓                │
│   ┌────────────┐   ┌────────────┐  ┌────────────┐         │
│   │ Worker A   │   │ Worker B   │  │ Worker C   │  ← 执行者│
│   │(库存服务)  │   │(支付服务)  │  │(物流服务)  │         │
│   └────────────┘   └────────────┘  └────────────┘         │
│                                                              │
│  优势：                                                       │
│  ✓ 流程逻辑集中在编排者                                       │
│  ✓ 执行者之间互不耦合                                         │
│  ✓ 易于修改流程（只改编排者）                                 │
│  ✓ 执行者可独立测试和复用                                     │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**代码示例：**
```cpp
// 执行者接口
class IInventoryService {
public:
    virtual void reserveItems(Order& order) = 0;
};

class IPaymentService {
public:
    virtual void chargePayment(double amount) = 0;
};

class IShippingService {
public:
    virtual void scheduleShipment(Order& order) = 0;
};

// 编排者：协调复杂流程
class OrderOrchestrator {
private:
    IInventoryService* inventory;
    IPaymentService* payment;
    IShippingService* shipping;
    
public:
    OrderOrchestrator(IInventoryService* inv, 
                      IPaymentService* pay,
                      IShippingService* ship)
        : inventory(inv), payment(pay), shipping(ship) {}
    
    // 编排下单流程
    void placeOrder(Order& order) {
        try {
            // 步骤1：预留库存
            inventory->reserveItems(order);
            
            // 步骤2：处理支付
            payment->chargePayment(order.getTotalAmount());
            
            // 步骤3：安排发货
            shipping->scheduleShipment(order);
            
            order.setStatus(OrderStatus::Confirmed);
        } catch (const std::exception& e) {
            // 统一处理流程错误
            order.setStatus(OrderStatus::Failed);
            throw;
        }
    }
};

// 使用场景：
// - 微服务编排：一个服务协调多个其他服务
// - 复杂业务流程：多步骤需按序执行
// - Saga模式：分布式事务协调
```

---

### Step 3: 逐层细化 – 模块内部设计迭代

```
┌─────────────────────────────────────────────────────────────┐
│              递归式设计细化过程                               │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  系统级 ───────┐                                             │
│   (架构)       │                                             │
│               ↓ 应用相同原则                                  │
│  模块级 ───────┤  高内聚 + 低耦合                             │
│   (服务)       │  接口 + 封装                                 │
│               ↓ 应用相同原则                                  │
│  类级   ───────┤  单一职责                                    │
│   (组件)       │  依赖倒置                                    │
│               ↓ 应用相同原则                                  │
│  函数级 ───────┘                                             │
│   (方法)                                                      │
│                                                              │
│  核心思想：                                                   │
│  无论在哪一层，都追求相同的设计目标                            │
│  "大尺度"系统设计 = "小尺度"OO设计                            │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

#### 细化步骤清单

| 步骤 | 关注点 | 方法 | 产出 |
|------|--------|------|------|
| **1. 内部拆分** | 模块是否过大？ | 按职责拆分子模块/类 | 职责单一的组件 |
| **2. 确定关系** | 如何协作？ | 优先组合 > 继承 | 类关系图 |
| **3. 接口封装** | 如何隐藏细节？ | 定义最小接口 | public API |
| **4. 考虑演化** | 未来如何变化？ | 应用OCP，预留扩展点 | 灵活的设计 |

#### 关键考量矩阵

| 维度 | 问题 | 解决方案 | 检验方法 |
|------|------|----------|----------|
| **职责** | 类是否做太多事？ | 拆分类，单一职责 | 能用一句话描述类职责吗？ |
| **依赖** | 是否直接依赖具体类？ | 依赖接口/抽象 | 能否Mock所有外部依赖？ |
| **扩展** | 新功能需修改旧代码？ | 策略模式/OCP | 能通过添加而非修改扩展吗？ |
| **测试** | 能否独立测试？ | 依赖注入 | 单元测试覆盖率>80%？ |
| **并发** | 是否线程安全？ | 封装同步机制 | 有竞态条件吗？ |

---

## ⚖️ 第二部分：依赖控制金字塔（战术层）

### 依赖关系六层级：从弱到强

```
┌─────────────────────────────────────────────────────────────┐
│                   依赖金字塔结构                              │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│              Lv-5 继承 (Inheritance) 🔴                      │
│             /    最强耦合，谨慎使用    \                      │
│            ────────────────────────────                      │
│          Lv-4 组合 (Composition) 🟠                          │
│         /    生命周期绑定，整体-部分    \                     │
│        ────────────────────────────────                      │
│       Lv-3 聚合 (Aggregation) 🟡                             │
│      /    集合关系，外部拥有所有权     \                      │
│     ──────────────────────────────────                       │
│    Lv-2 实现 (Realization) 🟢                                │
│   /    通过接口，支持替换，★推荐★    \                        │
│  ────────────────────────────────────────                    │
│ Lv-1 关联 (Association) 🔵                                   │
│/    长引用，不控制生命周期           \                        │
│──────────────────────────────────────────                    │
│Lv-0 依赖 (Dependency) ⚪                                      │
│  最弱耦合，临时使用，首选                                     │
│                                                              │
│  🎯 设计原则：                                                │
│  1. 尽量使用最弱的关系满足需求                                │
│  2. 证明必要性后才升级到更强关系                              │
│  3. ⚠️ 跨模块/服务禁用 Lv-4/Lv-5！                           │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

### Lv-0: 依赖 (Dependency) - 最弱 ⚪

```cpp
/**
 * 特征：临时使用，无持久引用
 * 耦合度：⭐ (最低)
 * 适用场景：工具函数、临时计算、参数传递
 */

class ReportGenerator {
public:
    // 通过参数传入，用完即丢
    void generate(const Data& data) {
        int sum = Utils::calculate(data);  // 调用工具函数
        // 使用后不保留引用
    }
    
    // 局部创建，函数结束即销毁
    void process() {
        Parser parser;  // 栈上临时对象
        parser.parse();
    }  // parser自动销毁
};
```

**优势：**
- ✅ 零持久耦合
- ✅ 函数级隔离
- ✅ 易于测试（纯函数）
- ✅ 无生命周期管理负担

**使用建议：**
- 首选此关系！
- 适合：工具类、算法函数、数据转换

---

### Lv-1: 关联 (Association) - 弱耦合 🔵

```cpp
/**
 * 特征：长期引用，但不控制生命周期
 * 耦合度：⭐⭐
 * 适用场景：观察者模式、视图-模型、回调
 */

class Model {
    std::string data;
public:
    std::string getData() const { return data; }
    void setData(const std::string& d) { data = d; }
};

class View {
    const Model* model_;  // 持有指针/引用
    
public:
    View(const Model* m) : model_(m) {}
    
    void update() {
        // 使用model_，但不负责创建/销毁
        std::cout << "显示: " << model_->getData() << "\n";
    }
    
    // ✓ Model在外部管理
    // ✓ View只是观察者
    // ✓ 生命周期独立
};

// 使用示例
int main() {
    Model model;
    View view(&model);  // View关联到Model
    
    model.setData("Hello");
    view.update();  // 显示: Hello
    
    // model和view生命周期独立
    // model销毁时，view也要确保不再访问
}
```

**优势：**
- ✅ 生命周期解耦
- ✅ 多个对象可共享同一引用
- ✅ 适合观察者/监听器模式

**注意事项：**
- ⚠️ 需确保被引用对象仍存在（避免悬空指针）
- ⚠️ 不拥有所有权，不负责delete

---

### Lv-2: 实现 (Realization) - 推荐 🟢

```cpp
/**
 * 特征：通过接口协作，支持替换
 * 耦合度：⭐⭐
 * 适用场景：跨模块依赖的首选方式！
 * 
 * ★★★ 这是实现依赖倒置(DIP)的核心机制 ★★★
 */

// 抽象接口（稳定）
class ICompressor {
public:
    virtual ~ICompressor() = default;
    virtual std::vector<byte> compress(const std::vector<byte>& data) = 0;
};

// 具体实现1
class GzipCompressor : public ICompressor {
    std::vector<byte> compress(const std::vector<byte>& data) override {
        // gzip压缩算法
        return compressedData;
    }
};

// 具体实现2
class LZ4Compressor : public ICompressor {
    std::vector<byte> compress(const std::vector<byte>& data) override {
        // lz4压缩算法
        return compressedData;
    }
};

// 高层模块（依赖接口）
class FileManager {
    ICompressor* compressor_;  // 依赖接口，非实现
    
public:
    // 依赖注入
    void setCompressor(ICompressor* c) { 
        compressor_ = c; 
    }
    
    void saveFile(const std::vector<byte>& data) {
        // 多态调用，运行时决定具体实现
        auto compressed = compressor_->compress(data);
        // 写入文件...
    }
};

// 使用：运行时切换算法
int main() {
    FileManager fm;
    
    GzipCompressor gzip;
    fm.setCompressor(&gzip);
    fm.saveFile(data);  // 使用gzip
    
    LZ4Compressor lz4;
    fm.setCompressor(&lz4);
    fm.saveFile(data);  // 切换到lz4，无需修改FileManager！
}

// 测试：注入Mock
class MockCompressor : public ICompressor {
    std::vector<byte> compress(const std::vector<byte>& data) override {
        return data;  // 不压缩，便于测试
    }
};

void testFileManager() {
    FileManager fm;
    MockCompressor mock;
    fm.setCompressor(&mock);  // 隔离真实压缩逻辑
    // 测试FileManager的其他逻辑...
}
```

**优势：**
- ✅ **依赖倒置（DIP）**：高层不依赖低层
- ✅ **易于测试**：可Mock所有依赖
- ✅ **运行时替换**：热插拔能力
- ✅ **开放-封闭**：添加新实现无需修改调用方

**跨模块依赖的黄金法则：**
```
┌──────────────────────────────────────┐
│   跨模块依赖必须通过接口！            │
│                                      │
│   模块A ──→ Interface ←── 模块B      │
│   (调用)      ↑          (实现)      │
│              │                       │
│          在中间定义                   │
│       (或由高层定义)                  │
└──────────────────────────────────────┘
```

---

### Lv-3: 聚合 (Aggregation) - 集合关系 🟡

```cpp
/**
 * 特征：整体包含部分，但不拥有所有权
 * 耦合度：⭐⭐⭐
 * 适用场景：集合容器、管理器、协调者
 */

class Entity {
public:
    void update() { /* 实体更新逻辑 */ }
};

class Scene {
    std::vector<Entity*> entities_;  // 外部创建的实体
    
public:
    void addEntity(Entity* e) {
        entities_.push_back(e);
    }
    
    void removeEntity(Entity* e) {
        entities_.erase(
            std::remove(entities_.begin(), entities_.end(), e),
            entities_.end()
        );
    }
    
    void updateAll() {
        for (auto* e : entities_) {
            e->update();  // 操作实体
        }
    }
    
    // ✓ 不负责delete entities
    // ✓ 整体-部分语义
    // ✓ 灵活的成员管理
};

// 使用示例
int main() {
    Scene scene;
    
    Entity e1, e2, e3;
    scene.addEntity(&e1);
    scene.addEntity(&e2);
    scene.addEntity(&e3);
    
    scene.updateAll();
    
    scene.removeEntity(&e2);
    
    // e1, e2, e3在scene之外管理生命周期
}
```

**优势：**
- ✅ 灵活的成员管理
- ✅ 多个容器可共享同一对象
- ✅ 适合动态集合

**注意事项：**
- ⚠️ 需明确所有权归属
- ⚠️ 避免悬空指针
- ⚠️ 文档中说明生命周期责任

---

### Lv-4: 组合 (Composition) - 强耦合 🟠

```cpp
/**
 * 特征：完全拥有部件，生命周期绑定
 * 耦合度：⭐⭐⭐⭐
 * 适用场景：仅用于模块内部！
 * 
 * ⚠️ 跨模块边界禁止使用组合！
 * 
 * 为什么跨模块禁止组合？
 * 组合 = 所有权 + 生命周期绑定
 * 
 * 跨模块组合的问题：
 * 1. 模块A拥有模块B对象 → 两个模块生命周期强绑定
 * 2. 无法独立编译测试ModuleA（必须依赖ModuleB）
 * 3. 换ModuleB实现需要重新编译ModuleA
 * 4. 违反模块独立性原则
 * 
 * 正确做法：跨模块用接口+依赖注入（Lv-2 实现）
 */

class Engine {
public:
    void start() { std::cout << "Engine started\n"; }
};

class Wheel {
    double diameter;
public:
    Wheel(double d) : diameter(d) {}
    void rotate() { std::cout << "Wheel rotating\n"; }
};

class GPS {
public:
    void navigate() { std::cout << "Navigating...\n"; }
};

class Car {
    // 值成员：完全拥有
    Engine engine_;        
    Wheel wheels_[4];      
    
    // 智能指针：拥有所有权
    std::unique_ptr<GPS> gps_;
    
public:
    Car() 
        : engine_()
        , wheels_{Wheel(20), Wheel(20), Wheel(20), Wheel(20)}
        , gps_(std::make_unique<GPS>())
    {
        // Car创建时，所有部件同时创建
    }
    
    // Car销毁时，所有部件自动销毁
    ~Car() {
        // engine_, wheels_ 自动销毁
        // gps_ 通过unique_ptr自动delete
    }
    
    void drive() {
        engine_.start();
        for (auto& wheel : wheels_) {
            wheel.rotate();
        }
        gps_->navigate();
    }
};

// Engine、Wheel、GPS 的生命周期完全由Car控制
```

**优势：**
- ✅ 强整体-部分关系明确
- ✅ 生命周期自动管理（RAII）
- ✅ 实现细节完全封装

**限制：**
- ⚠️ **仅用于模块内部**
- ⚠️ **跨模块禁止组合**
- ⚠️ 高耦合，难以替换部件

**黄金法则：**
```
组合 = 所有权 + 生命周期绑定

✓ 模块内部：Car组合Engine（可以）
✗ 跨模块：ServiceA组合ServiceB（禁止！）

原因：跨模块组合导致：
  - 模块边界被破坏
  - 无法独立部署
  - 测试困难
  - 高度耦合
```

---

### Lv-5: 继承 (Inheritance) - 最强 🔴

```cpp
/**
 * 特征：is-a关系，编译时绑定
 * 耦合度：⭐⭐⭐⭐⭐ (最高)
 * 适用场景：极少！必须满足严格条件
 * 
 * ⚠️⚠️⚠️ 慎用继承！优先考虑组合 ⚠️⚠️⚠️
 * ⚠️⚠️⚠️ 跨模块边界禁止继承！ ⚠️⚠️⚠️
 */

// ✅ 正确使用：接口多态
class Shape {  // 抽象基类
public:
    virtual ~Shape() = default;  // ✓ 虚析构函数
    virtual void draw() const = 0;
    virtual double area() const = 0;
};

class Circle : public Shape {  // Circle is-a Shape
    double radius_;
public:
    Circle(double r) : radius_(r) {}
    
    void draw() const override {
        std::cout << "Drawing circle\n";
    }
    
    double area() const override {
        return 3.14159 * radius_ * radius_;
    }
};

class Rectangle : public Shape {  // Rectangle is-a Shape
    double width_, height_;
public:
    Rectangle(double w, double h) : width_(w), height_(h) {}
    
    void draw() const override {
        std::cout << "Drawing rectangle\n";
    }
    
    double area() const override {
        return width_ * height_;
    }
};

// 使用多态
void drawAll(const std::vector<Shape*>& shapes) {
    for (const auto* shape : shapes) {
        shape->draw();  // 运行时多态
    }
}

// ❌ 错误使用：仅为代码复用
class Stack : public std::vector<int> {  // ❌ Stack is-a Vector?
    // 问题：暴露了vector的所有方法
    // 问题：Stack不应该支持随机访问
};

// ✅ 应该用组合
class Stack {
    std::vector<int> data_;  // 组合
public:
    void push(int x) { data_.push_back(x); }
    int pop() { 
        int x = data_.back(); 
        data_.pop_back(); 
        return x; 
    }
    // 只暴露Stack需要的接口
};
```

**使用继承的5个必要条件（全部满足才可用）：**

| # | 条件 | 说明 | 检验方法 |
|---|------|------|----------|
| 1 | **is-a关系** | 子类确实是父类的一种 | "Circle is a Shape" 成立吗？ |
| 2 | **需要多态** | 运行时需要替换不同实现 | 需要通过基类指针调用吗？ |
| 3 | **复用实现** | 需要继承父类的通用代码 | 有共同行为需要复用吗？ |
| 4 | **浅层次** | 继承深度 ≤ 3层 | 层次是否太深？ |
| 5 | **虚析构** | 基类有`virtual ~Base()` | 基类析构函数是虚的吗？ |

**继承的问题：**
```
❌ 子类依赖父类实现细节（脆基类问题）
❌ 改变父类影响所有子类
❌ 编译时绑定，缺乏灵活性
❌ 容易违反里氏替换原则(LSP)
❌ 跨模块继承破坏边界
```

**替代方案：**
```cpp
// 不要这样（继承仅为复用）
class Logger : public FileWriter {
    void log(const std::string& msg) {
        write(msg);  // 复用FileWriter的write
    }
};

// 应该这样（组合）
class Logger {
    FileWriter writer_;  // 组合
public:
    void log(const std::string& msg) {
        writer_.write(msg);  // 委托
    }
};
```

**跨边界继承禁令：**
```
┌─────────────────────────────────────────────────────────────┐
│   ⚠️ 跨模块/服务禁止继承！                                   │
│                                                              │
│   模块A的类 ✗ 继承 模块B的类                                 │
│                                                              │
│   原因详解：                                                  │
│                                                              │
│   1. 破坏模块封装                                             │
│      子类可以访问父类的protected成员                          │
│      → 模块B的内部实现泄漏给模块A                             │
│                                                              │
│   2. 无法独立演化                                             │
│      修改父类（模块B）→ 必须重新编译子类（模块A）             │
│      → 两个模块捆绑在一起                                     │
│                                                              │
│   3. 版本兼容性噩梦                                           │
│      父类改变内部实现 → 子类代码崩溃                          │
│      → 必须同时升级两个模块                                   │
│                                                              │
│   4. 测试困难                                                 │
│      测试子类必须依赖父类的具体实现                           │
│      → 无法Mock，变成集成测试                                 │
│                                                              │
│   5. ABI兼容问题                                              │
│      虚函数表布局变化 → 二进制不兼容                          │
│                                                              │
│   实际案例：                                                  │
│   团队A: OrderService (订单模块)                             │
│   团队B: PaymentProcessor (支付模块)                         │
│   如果OrderService继承PaymentProcessor：                      │
│   - 团队B修改PaymentProcessor内部 → 团队A代码崩溃            │
│   - 无法独立部署 → 必须协调发布                               │
│   - 测试OrderService需要真实PaymentProcessor                 │
│                                                              │
│   正确做法：通过接口交互                                      │
│   OrderService依赖IPaymentService接口                        │
│   PaymentProcessor实现IPaymentService                        │
│   → 两个模块完全解耦                                          │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

### 依赖选择决策树

```
           需要建立关系？
                ↓
         ┌──────┴──────┐
         是            否 → 不需要依赖
         ↓
    是否临时使用？
         ↓
    ┌────┴────┐
    是        否
    ↓         ↓
Lv-0依赖✓  需要长期引用？
    |          ↓
    |     ┌────┴────┐
    |     是        否
    |     ↓         → 重新考虑设计
    | 是否控制生命周期？
    |     ↓
    | ┌───┴───┐
    | 否      是
    | ↓       ↓
    | 能否   是否
    | 通过   is-a？
    | 接口？  ↓
    | ↓   ┌──┴──┐
    | 是  否     是
    | ↓   ↓      ↓
Lv-2实现✓ Lv-4组合 Lv-5继承
         (仅内部) (慎用！)
         Lv-3聚合
         Lv-1关联
```

---

### 跨边界依赖规则总结

| 边界类型 | 允许的关系 | 禁止的关系 | 原因 |
|----------|-----------|-----------|------|
| **跨服务** | Lv-0 依赖<br>API调用<br>消息通信 | Lv-1~5 全部禁止 | 服务独立部署，共享内存不可行 |
| **跨模块** | Lv-0 依赖<br>Lv-1 关联<br>**Lv-2 实现**★ | Lv-4 组合<br>Lv-5 继承 | 破坏模块封装，高度耦合 |
| **模块内部** | Lv-0~5 皆可 | 过深继承(>3层) | 内部实现细节，可控范围 |
| **类内部** | Lv-0~5 皆可 | 循环依赖 | 类的实现细节 |

**记忆口诀：**
```
跨服务只消息，
跨模块用接口，
模块内灵活用，
继承要慎重。
```

---

## 🛡️ 第二部分：SOLID + 8项黄金法则详解

### SOLID五大原则完整解析

```
┌─────────────────────────────────────────────────────────────┐
│                      SOLID原则体系                           │
├────────┬────────────────────────────────────────────────────┤
│   S    │ Single Responsibility Principle (单一职责)         │
│        │ 一个类只有一个变化的原因                            │
│        │ 变化原因 = 职责                                     │
├────────┼────────────────────────────────────────────────────┤
│   O    │ Open-Closed Principle (开放-封闭)                  │
│        │ 对扩展开放，对修改封闭                              │
│        │ 通过抽象实现扩展                                    │
├────────┼────────────────────────────────────────────────────┤
│   L    │ Liskov Substitution Principle (里氏替换)           │
│        │ 子类可以替换父类而不破坏程序                        │
│        │ 前置条件不强化，后置条件不弱化                      │
├────────┼────────────────────────────────────────────────────┤
│   I    │ Interface Segregation Principle (接口隔离)         │
│        │ 多个专用接口优于一个通用接口                         │
│        │ 客户端不应依赖不需要的方法                          │
├────────┼────────────────────────────────────────────────────┤
│   D    │ Dependency Inversion Principle (依赖倒置)          │
│        │ 依赖抽象，而非具体实现                              │
│        │ 高层和低层都依赖抽象                                │
└────────┴────────────────────────────────────────────────────┘
```

---

#### 1. 单一职责原则 (SRP) 详解

**核心思想：** 一个类应该只有一个引起它变化的原因

```cpp
// ❌ 违反SRP：混合了多种职责
class Employee {
    std::string name;
    double salary;
    
public:
    // 职责1：计算工资（财务部门关心）
    double calculatePay() {
        return salary * 1.1;
    }
    
    // 职责2：保存数据（IT部门关心）
    void save() {
        // 数据库操作
    }
    
    // 职责3：生成报表（报表部门关心）
    std::string generateReport() {
        return "Report for " + name;
    }
};
// 问题：三个部门的需求变化都会导致修改这个类！

// ✅ 遵循SRP：按职责拆分
class Employee {
    std::string name;
    double salary;
public:
    std::string getName() const { return name; }
    double getSalary() const { return salary; }
};

class PayrollCalculator {  // 职责：工资计算
public:
    double calculatePay(const Employee& emp) {
        return emp.getSalary() * 1.1;
    }
};

class EmployeeRepository {  // 职责：数据持久化
public:
    void save(const Employee& emp) {
        // 数据库操作
    }
};

class EmployeeReportGenerator {  // 职责：报表生成
public:
    std::string generate(const Employee& emp) {
        return "Report for " + emp.getName();
    }
};
```

**SRP实践技巧：**

| 检测方法 | 说明 | 修复方法 |
|----------|------|----------|
| **描述测试** | 用一句话描述类职责，如果需要用"和"连接 | 拆分类 |
| **变化原因** | 列出可能修改类的原因，超过1个 | 按原因分离 |
| **依赖方向** | 被太多不同领域的类依赖 | 提取接口 |
| **方法分组** | 方法明显分成几组，各组很少互相调用 | 拆分为独立类 |

**目录结构反映SRP：**
```
// ❌ 按技术分层（职责混乱）
/src
  /controllers  (所有控制器)
  /services     (所有服务)
  /repositories (所有数据访问)

// ✅ 按业务领域（职责清晰）
/src
  /user-domain
    UserService.cpp
    UserRepository.cpp
    UserValidator.cpp
  /order-domain
    OrderService.cpp
    OrderRepository.cpp
    OrderCalculator.cpp
```

**SRP在嵌套职责中的应用：**

现实中，许多职责是嵌套的：一个单一职责可能由多层子职责组合而成。解决方法是**职责分层设计**。

```
┌─────────────────────────────────────────────────────────────┐
│           职责的层次化分解思维                                │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  高层职责：业务能力（What）                                   │
│      ↓                                                       │
│  中层职责：业务流程（How）                                    │
│      ↓                                                       │
│  底层职责：技术细节（Detail）                                 │
│                                                              │
│  原则：                                                       │
│  1. 每一层的类只负责本层的职责                                │
│  2. 不同层次的职责由不同的类承担                              │
│  3. 通过组合/编排协调子职责                                   │
│  4. 职责边界在同一抽象层次                                    │
│                                                              │
│  示例：用户注册流程                                           │
│  ┌──────────────────────────────────────┐                  │
│  │ UserRegistrationUseCase (高层编排)   │                  │
│  │ 职责：编排用户注册业务流程            │                  │
│  └────┬─────────┬─────────┬─────────┬───┘                  │
│       ↓         ↓         ↓         ↓                        │
│  Validator Repository EmailSvc EventBus (中层服务)          │
│  验证规则   数据访问   邮件发送  事件发布                     │
│       ↓         ↓         ↓                                  │
│  EmailValidator MySQLImpl SMTPClient (底层实现)              │
│  正则验证      SQL操作   SMTP协议                            │
│                                                              │
│  记忆口诀：                                                   │
│  职责有层次，分层来解决                                       │
│  高层编排流程，中层实现规则                                   │
│  底层技术细节，各司其职不乱                                   │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

```cpp
// 实战示例：订单处理的职责分层

// ========== 层次1：原子服务（最小职责）==========
class InventoryChecker {  // 单一职责：检查库存
    bool hasStock(int productId, int quantity) const;
};

class CouponValidator {  // 单一职责：验证优惠码
    bool isValid(const std::string& code, int userId) const;
};

// ========== 层次2：领域服务（组合职责）==========
class OrderValidator {  // 职责：组合多个验证规则
    InventoryChecker inventoryChecker_;
    CouponValidator couponValidator_;
    
    ValidationResult validate(const Order& order) const {
        // 协调多个验证器
    }
};

class PriceCalculator {  // 职责：价格计算逻辑
    PriceBreakdown calculate(const Order& order) const;
};

// ========== 层次3：应用服务（编排职责）==========
class PlaceOrderUseCase {  // 职责：编排订单处理流程
    OrderValidator validator_;
    PriceCalculator priceCalculator_;
    IInventoryService* inventoryService_;
    IPaymentGateway* paymentGateway_;
    
    OrderResult execute(const CreateOrderRequest& request) {
        // 步骤1：验证订单（委托给验证器）
        auto validationResult = validator_.validate(order);
        
        // 步骤2：计算价格（委托给计算器）
        auto pricing = priceCalculator_.calculate(order);
        
        // 步骤3：预留库存（委托给库存服务）
        inventoryService_->reserve(order.getItems());
        
        // 步骤4：处理支付（委托给支付网关）
        paymentGateway_->charge(pricing.total, request.getPaymentMethod());
        
        // 编排者只负责协调，不包含具体业务逻辑！
    }
};
```

**关键要点：**
- SRP不是让每个类只有一个方法
- 而是在**同一抽象层次**的单一职责
- 复杂职责通过**分层+分治**处理
- **编排者模式**协调子职责
- 测试困难往往说明职责太多

---

#### 2. 开放-封闭原则 (OCP) 详解

**核心思想：** 软件实体应该对扩展开放，对修改封闭

```
┌─────────────────────────────────────────────────────────────┐
│              OCP 开放-封闭原则                                │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  软件实体（类、模块、函数等）应该：                           │
│                                                              │
│     ✅ 对扩展开放 (Open for Extension)                       │
│        允许添加新功能                                         │
│                                                              │
│     ✅ 对修改封闭 (Closed for Modification)                  │
│        不修改现有代码                                         │
│                                                              │
│  核心思想：                                                   │
│  通过添加新代码来扩展功能                                     │
│  而不是修改已有的、稳定的代码                                 │
│                                                              │
│  实现方式：继承、策略、装饰、模板方法、观察者...              │
│                                                              │
│  记住：OCP不是目标，而是手段                                  │
│        为应对变化而设计，不为抽象而抽象                       │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

```cpp
// ❌ 违反OCP：每次添加新类型都要修改
class ShapeDrawer {
public:
    void drawShapes(const std::vector<Shape>& shapes) {
        for (const auto& shape : shapes) {
            if (shape.type == "Circle") {
                // 绘制圆形
            } else if (shape.type == "Rectangle") {
                // 绘制矩形
            } else if (shape.type == "Triangle") {
                // 绘制三角形  ← 每次新增都要改这里
            }
            // ... 越来越多的if-else
        }
    }
};

// ✅ 遵循OCP：通过抽象扩展
class Shape {  // 抽象
public:
    virtual ~Shape() = default;
    virtual void draw() const = 0;
};

class Circle : public Shape {
    void draw() const override {
        std::cout << "Drawing Circle\n";
    }
};

class Rectangle : public Shape {
    void draw() const override {
        std::cout << "Drawing Rectangle\n";
    }
};

class Triangle : public Shape {  // 新增类型：只需添加，无需修改
    void draw() const override {
        std::cout << "Drawing Triangle\n";
    }
};

class ShapeDrawer {
public:
    void drawShapes(const std::vector<Shape*>& shapes) {
        for (const auto* shape : shapes) {
            shape->draw();  // 多态调用，永远不需要修改
        }
    }
};
```

**OCP + 策略模式示例：**

```cpp
// 压缩策略接口
class ICompressionStrategy {
public:
    virtual ~ICompressionStrategy() = default;
    virtual std::vector<byte> compress(const std::vector<byte>& data) = 0;
};

// 具体策略：Gzip
class GzipStrategy : public ICompressionStrategy {
    std::vector<byte> compress(const std::vector<byte>& data) override {
        // Gzip压缩实现
    }
};

// 具体策略：LZ4
class LZ4Strategy : public ICompressionStrategy {
    std::vector<byte> compress(const std::vector<byte>& data) override {
        // LZ4压缩实现
    }
};

// 上下文类（对修改封闭）
class FileCompressor {
    ICompressionStrategy* strategy_;
public:
    void setStrategy(ICompressionStrategy* s) { 
        strategy_ = s; 
    }
    
    void compressFile(const std::string& filename) {
        auto data = readFile(filename);
        auto compressed = strategy_->compress(data);  // 委托给策略
        writeFile(filename + ".compressed", compressed);
    }
};

// 扩展：添加新策略（对扩展开放）
class BrotliStrategy : public ICompressionStrategy {  // 新策略
    std::vector<byte> compress(const std::vector<byte>& data) override {
        // Brotli压缩实现
    }
};
// FileCompressor无需任何修改！
```

**实现OCP的技术手段：**

| 技术 | 适用场景 | 示例 |
|------|----------|------|
| **继承/多态** | 行为变化 | Shape派生类 |
| **策略模式** | 算法替换 | 压缩策略 |
| **模板方法** | 流程框架 | 游戏循环 |
| **装饰者** | 功能叠加 | IO流装饰 |
| **观察者** | 事件响应 | UI事件系统 |

---

#### 3. 里氏替换原则 (LSP) 详解

**核心思想：** 子类对象必须能够替换父类对象，而不破坏程序正确性

```cpp
// ❌ 违反LSP：正方形不是矩形的正确子类
class Rectangle {
protected:
    int width_, height_;
public:
    virtual void setWidth(int w) { width_ = w; }
    virtual void setHeight(int h) { height_ = h; }
    int getArea() const { return width_ * height_; }
};

class Square : public Rectangle {
public:
    void setWidth(int w) override {
        width_ = height_ = w;  // 保持正方形性质
    }
    void setHeight(int h) override {
        width_ = height_ = h;
    }
};

// 问题出现：
void testRectangle(Rectangle* rect) {
    rect->setWidth(5);
    rect->setHeight(4);
    assert(rect->getArea() == 20);  // 对Rectangle成立
    // 但传入Square会失败！getArea() == 16
}

// ✅ 遵循LSP：不使用继承，使用组合
class Shape {
public:
    virtual ~Shape() = default;
    virtual int getArea() const = 0;
};

class Rectangle : public Shape {
    int width_, height_;
public:
    Rectangle(int w, int h) : width_(w), height_(h) {}
    void resize(int w, int h) { width_ = w; height_ = h; }
    int getArea() const override { return width_ * height_; }
};

class Square : public Shape {
    int side_;
public:
    Square(int side) : side_(side) {}
    void resize(int side) { side_ = side; }
    int getArea() const override { return side_ * side_; }
};
// Rectangle和Square是平等的Shape，不存在替换问题
```

**LSP违反的信号：**

```
🚩 子类重写方法时：
  - 抛出父类未声明的异常
  - 接受比父类更窄的输入范围（强化前置条件）
  - 返回比父类更宽的输出范围（弱化后置条件）
  - 改变了方法的副作用

🚩 使用时需要：
  - 用instanceof检查类型
  - 向下转型（downcast）
  - 针对子类特殊处理

🚩 测试时：
  - 子类无法通过父类的测试用例
```

**LSP契约设计：**

```cpp
class Bird {
public:
    virtual ~Bird() = default;
    virtual void eat() = 0;
    // ❌ 不要定义：virtual void fly() = 0;
    // 因为企鹅不会飞，会违反LSP
};

class FlyingBird : public Bird {
public:
    virtual void fly() = 0;  // ✓ 只在会飞的鸟中定义
};

class Sparrow : public FlyingBird {
    void eat() override { /* ... */ }
    void fly() override { /* ... */ }
};

class Penguin : public Bird {  // ✓ 企鹅不继承FlyingBird
    void eat() override { /* ... */ }
    // 没有fly方法
};
```

---

#### 4. 接口隔离原则 (ISP) 详解

**核心思想：** 客户端不应该依赖它不使用的方法

```cpp
// ❌ 违反ISP：臃肿的接口
class IWorker {
public:
    virtual void work() = 0;
    virtual void eat() = 0;
    virtual void sleep() = 0;
    virtual void attendMeeting() = 0;
};

class HumanWorker : public IWorker {
    void work() override { /* ... */ }
    void eat() override { /* ... */ }
    void sleep() override { /* ... */ }
    void attendMeeting() override { /* ... */ }
};

class RobotWorker : public IWorker {
    void work() override { /* ... */ }
    void eat() override { /* 机器人不吃饭！ */ }  // ❌ 被迫实现
    void sleep() override { /* 机器人不睡觉！ */ }  // ❌ 被迫实现
    void attendMeeting() override { /* ... */ }
};

// ✅ 遵循ISP：小而精的接口
class IWorkable {
public:
    virtual ~IWorkable() = default;
    virtual void work() = 0;
};

class IFeedable {
public:
    virtual ~IFeedable() = default;
    virtual void eat() = 0;
};

class IRestable {
public:
    virtual ~IRestable() = default;
    virtual void sleep() = 0;
};

class IMeetingAttendee {
public:
    virtual ~IMeetingAttendee() = default;
    virtual void attendMeeting() = 0;
};

// 人类工人：实现所有接口
class HumanWorker : public IWorkable, 
                     public IFeedable, 
                     public IRestable,
                     public IMeetingAttendee {
    void work() override { /* ... */ }
    void eat() override { /* ... */ }
    void sleep() override { /* ... */ }
    void attendMeeting() override { /* ... */ }
};

// 机器人：只实现需要的接口
class RobotWorker : public IWorkable, 
                     public IMeetingAttendee {
    void work() override { /* ... */ }
    void attendMeeting() override { /* ... */ }
    // ✓ 不需要实现eat/sleep
};
```

**ISP实践：接口分离策略**

```cpp
// 文件操作的接口分离
class IReadable {
public:
    virtual std::string read() = 0;
};

class IWritable {
public:
    virtual void write(const std::string& data) = 0;
};

class ISeekable {
public:
    virtual void seek(size_t pos) = 0;
};

// 只读文件：只实现读
class ReadOnlyFile : public IReadable {
    std::string read() override { /* ... */ }
};

// 只写日志：只实现写
class LogFile : public IWritable {
    void write(const std::string& data) override { /* ... */ }
};

// 完整文件：实现所有
class RandomAccessFile : public IReadable, 
                          public IWritable, 
                          public ISeekable {
    std::string read() override { /* ... */ }
    void write(const std::string& data) override { /* ... */ }
    void seek(size_t pos) override { /* ... */ }
};
```

---

#### 5. 依赖倒置原则 (DIP) 深度解析

**核心思想：** 
1. 高层模块不依赖低层模块，都依赖抽象
2. 抽象不依赖细节，细节依赖抽象

**跨模块接口位置策略：**

```
┌─────────────────────────────────────────────────────────────┐
│              接口归属的黄金法则                               │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  理想情况：接口由需求方（高层）定义                           │
│                                                              │
│  现实约束：底层库不能依赖高层库（构建系统限制）               │
│                                                              │
│  解决方案：                                                   │
│                                                              │
│  策略1：独立接口层（最优）⭐⭐⭐⭐⭐                           │
│  ┌─────────────┐                                            │
│  │ Application │  ← 高层                                    │
│  └──────┬──────┘                                            │
│         │ depends                                           │
│         ↓                                                    │
│  ┌─────────────┐  ← 接口层（独立库）                        │
│  │ Interfaces  │     只有头文件                             │
│  └──────▲──────┘                                            │
│         │ implements                                        │
│  ┌──────┴──────┐                                            │
│  │DatabaseImpl │  ← 底层                                    │
│  └─────────────┘                                            │
│  优势：完全解耦、独立编译、易于测试                           │
│                                                              │
│  策略2：接口在底库导出（务实）⭐⭐⭐⭐                         │
│  ┌────────────┐    ┌────────────┐                          │
│  │Application │ → │ Database   │  ← 底库                    │
│  └────────────┘    │  Library   │                          │
│                    ├────────────┤                          │
│                    │ IDatabase  │  ← 导出接口                │
│                    │(public API)│                          │
│                    └────────────┘                          │
│  优势：自包含、易分发（单个.so）                             │
│                                                              │
│  策略3：插件架构（灵活）⭐⭐⭐⭐                               │
│  主程序定义接口 → 插件实现 → 运行时动态加载                  │
│  优势：零编译依赖、热插拔                                     │
│                                                              │
│  选择标准：项目规模、团队结构、构建约束、演化需求             │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

```
┌──────────────────────────────────────────────────────────┐
│           依赖倒置前 vs 倒置后                            │
├──────────────────────────────────────────────────────────┤
│  传统依赖（高层→低层）                                    │
│  ┌─────────────┐                                         │
│  │ Application │ ──────→ ┌──────────┐                   │
│  │   Layer     │         │ Database │                   │
│  │   (高层)    │         │  Layer   │                   │
│  └─────────────┘         │ (低层)   │                   │
│                          └──────────┘                   │
│  问题：Application依赖具体数据库实现                      │
│                                                          │
│  依赖倒置（都依赖抽象）                                   │
│  ┌─────────────┐                                         │
│  │ Application │                                         │
│  │   Layer     │                                         │
│  └──────┬──────┘                                         │
│         │ 依赖                                           │
│         ↓                                                │
│  ┌─────────────┐  ← 抽象层（最稳定）                     │
│  │ IRepository │                                         │
│  └──────▲──────┘                                         │
│         │ 实现                                           │
│         │                                                │
│  ┌──────┴──────────┐                                     │
│  │ DatabaseImpl    │  ← 实现层（可替换）                 │
│  └─────────────────┘                                     │
│                                                          │
│  优势：                                                   │
│  ✓ Application不知道Database存在                         │
│  ✓ 可随时替换数据库实现                                   │
│  ✓ 便于单元测试（Mock IRepository）                      │
│  ✓ 稳定的依赖方向                                        │
└──────────────────────────────────────────────────────────┘
```

**DIP完整示例：**

```cpp
// 1. 定义抽象（由高层定义）
class INotificationService {
public:
    virtual ~INotificationService() = default;
    virtual void send(const std::string& message, 
                      const std::string& recipient) = 0;
};

// 2. 高层业务逻辑（依赖抽象）
class OrderService {
    INotificationService* notifier_;  // 依赖接口
    
public:
    OrderService(INotificationService* notifier) 
        : notifier_(notifier) {}
    
    void placeOrder(const Order& order) {
        // 业务逻辑...
        
        // 通知客户（不知道具体如何通知）
        notifier_->send("Order confirmed", order.getCustomerEmail());
    }
};

// 3. 低层实现（实现抽象）
class EmailNotificationService : public INotificationService {
    void send(const std::string& message, 
              const std::string& recipient) override {
        // SMTP发送邮件
        std::cout << "Email to " << recipient << ": " << message << "\n";
    }
};

class SMSNotificationService : public INotificationService {
    void send(const std::string& message, 
              const std::string& recipient) override {
        // 短信网关发送
        std::cout << "SMS to " << recipient << ": " << message << "\n";
    }
};

// 4. 依赖注入（组装）
int main() {
    // 配置1：使用邮件通知
    EmailNotificationService emailService;
    OrderService orderService1(&emailService);
    
    // 配置2：使用短信通知
    SMSNotificationService smsService;
    OrderService orderService2(&smsService);
    
    // OrderService完全不知道底层实现细节！
}

// 5. 测试：注入Mock
class MockNotificationService : public INotificationService {
    std::vector<std::string> sentMessages;
public:
    void send(const std::string& message, 
              const std::string& recipient) override {
        sentMessages.push_back(message);
    }
    
    size_t getSentCount() const { return sentMessages.size(); }
};

void testOrderService() {
    MockNotificationService mock;
    OrderService service(&mock);
    
    service.placeOrder(order);
    
    assert(mock.getSentCount() == 1);  // 验证发送了通知
}
```

**DIP的三种注入方式：**

```cpp
class UserService {
    IDatabase* db_;
    ILogger* logger_;
    
public:
    // 方式1：构造函数注入（推荐）
    UserService(IDatabase* db, ILogger* logger) 
        : db_(db), logger_(logger) {}
    
    // 方式2：Setter注入
    void setDatabase(IDatabase* db) { db_ = db; }
    void setLogger(ILogger* logger) { logger_ = logger; }
    
    // 方式3：方法注入（临时依赖）
    void createUser(const User& user, IValidator* validator) {
        if (validator->validate(user)) {
            db_->save(user);
        }
    }
};
```

---

### 8项黄金法则总结

除了SOLID五大原则，还有三项关键实践：

#### 6. 信息隐藏（封装）

```cpp
// ❌ 违反封装：暴露内部实现
class Stack {
public:
    std::vector<int> data;  // ❌ 公开内部容器
};

// ✅ 正确封装：隐藏实现细节
class Stack {
    std::vector<int> data_;  // private
public:
    void push(int x) { data_.push_back(x); }
    int pop() { 
        int x = data_.back(); 
        data_.pop_back(); 
        return x; 
    }
    size_t size() const { return data_.size(); }
    bool empty() const { return data_.empty(); }
    // 不暴露vector的其他方法（如随机访问）
};
```

**C++封装技巧：**
- ✅ 头文件只声明公共接口
- ✅ 实现细节放在.cpp文件
- ✅ 使用Pimpl惯用法隐藏私有成员
- ✅ 前向声明减少头文件依赖

```cpp
// Widget.h
class WidgetImpl;  // 前向声明

class Widget {
    std::unique_ptr<WidgetImpl> pImpl;  // Pimpl
public:
    Widget();
    ~Widget();
    void doSomething();
    // 客户端看不到WidgetImpl的细节
};

// Widget.cpp
class WidgetImpl {
    // 所有私有成员和实现细节
    ComplexDependency dep_;
public:
    void doSomethingImpl() { /* ... */ }
};

Widget::Widget() : pImpl(std::make_unique<WidgetImpl>()) {}
Widget::~Widget() = default;
void Widget::doSomething() { pImpl->doSomethingImpl(); }
```

---

#### 7. 优先组合而非继承

```cpp
// ❌ 滥用继承：为了代码复用
class ArrayList : public std::vector<int> {
public:
    void addUnique(int x) {
        if (std::find(begin(), end(), x) == end()) {
            push_back(x);
        }
    }
};
// 问题：暴露了vector的所有方法，破坏了ArrayList的语义

// ✅ 使用组合
class UniqueList {
    std::vector<int> data_;  // 组合
public:
    void add(int x) {
        if (std::find(data_.begin(), data_.end(), x) == data_.end()) {
            data_.push_back(x);
        }
    }
    
    size_t size() const { return data_.size(); }
    
    // 只暴露需要的接口
};
```

**何时用继承 vs 组合：**

| 场景 | 推荐 | 原因 |
|------|------|------|
| 实现接口多态 | 继承 | 需要运行时多态 |
| 代码复用 | 组合 | 避免暴露不需要的方法 |
| 扩展功能 | 组合+委托 | 灵活性更高 |
| is-a关系 | 继承 | 符合语义 |
| has-a关系 | 组合 | 符合语义 |

---

#### 8. 资源所有权管理（C++特有）

```cpp
// 所有权语义清单
class ResourceManager {
    // 唯一所有权
    std::unique_ptr<Resource> owned_;
    
    // 共享所有权
    std::shared_ptr<SharedResource> shared_;
    
    // 不拥有（借用）
    Resource* borrowed_;
    const Resource& referenced_;
    
public:
    // 转移所有权
    void takeOwnership(std::unique_ptr<Resource> res) {
        owned_ = std::move(res);
    }
    
    // 共享所有权
    void shareOwnership(std::shared_ptr<SharedResource> res) {
        shared_ = res;
    }
    
    // 借用（不管理生命周期）
    void borrow(Resource* res) {
        borrowed_ = res;  // 调用者确保res有效
    }
};
```

**RAII原则：**
```cpp
class FileHandle {
    FILE* file_;
public:
    FileHandle(const char* filename) {
        file_ = fopen(filename, "r");  // 构造时获取
        if (!file_) throw std::runtime_error("Failed to open");
    }
    
    ~FileHandle() {
        if (file_) fclose(file_);  // 析构时释放
    }
    
    // 禁止拷贝
    FileHandle(const FileHandle&) = delete;
    FileHandle& operator=(const FileHandle&) = delete;
    
    // 允许移动
    FileHandle(FileHandle&& other) noexcept : file_(other.file_) {
        other.file_ = nullptr;
    }
    
    FILE* get() { return file_; }
};
```

---

## 🏛️ 第三部分：架构模式（实施层）

### 三大架构模式对比

```
┌─────────────────────────────────────────────────────────────┐
│                   架构模式选择                                │
├──────────────┬─────────────┬──────────────┬────────────────┤
│   模式       │  适用场景   │   优势       │   劣势         │
├──────────────┼─────────────┼──────────────┼────────────────┤
│ 分层架构     │ 传统企业应用│ 简单清晰     │ 层间耦合       │
│ (Layered)    │ CRUD系统    │ 易于理解     │ 性能开销       │
├──────────────┼─────────────┼──────────────┼────────────────┤
│ 六边形架构   │ DDD项目     │ 核心独立     │ 学习曲线       │
│ (Hexagonal)  │ 微服务      │ 易测试       │ 复杂度高       │
├──────────────┼─────────────┼──────────────┼────────────────┤
│ 事件驱动     │ 高并发系统  │ 解耦性强     │ 调试困难       │
│ (Event-Driven)│ 实时系统   │ 可扩展       │ 复杂度高       │
└──────────────┴─────────────┴──────────────┴────────────────┘
```

---

### 1. 分层架构（Layered Architecture）

```
┌─────────────────────────────────────────────────────────────┐
│                  经典四层架构                                 │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌──────────────────────────────────────────┐              │
│  │   Presentation Layer (表示层)            │              │
│  │   UI / API / Controllers                 │              │
│  └──────────────┬───────────────────────────┘              │
│                 │ 调用                                       │
│                 ↓                                            │
│  ┌──────────────────────────────────────────┐              │
│  │   Application Layer (应用层)             │              │
│  │   Use Cases / Orchestrators              │              │
│  └──────────────┬───────────────────────────┘              │
│                 │ 调用                                       │
│                 ↓                                            │
│  ┌──────────────────────────────────────────┐              │
│  │   Domain Layer (领域层)                  │              │
│  │   Business Logic / Entities              │              │
│  └──────────────┬───────────────────────────┘              │
│                 │ 调用                                       │
│                 ↓                                            │
│  ┌──────────────────────────────────────────┐              │
│  │   Infrastructure Layer (基础设施层)       │              │
│  │   Database / Network / File System       │              │
│  └──────────────────────────────────────────┘              │
│                                                              │
│  依赖方向：单向向下                                           │
│  ⚠️ 领域层不应直接依赖基础设施层！                            │
│     通过接口+依赖注入解决                                     │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**代码示例：**

```cpp
// ========== Domain Layer ==========
// 领域实体（纯业务逻辑）
class User {
    int id_;
    std::string email_;
    std::string password_hash_;
    
public:
    bool validatePassword(const std::string& password) const {
        return hashPassword(password) == password_hash_;
    }
    
    void changeEmail(const std::string& newEmail) {
        if (!isValidEmail(newEmail)) {
            throw std::invalid_argument("Invalid email");
        }
        email_ = newEmail;
    }
};

// 领域层定义的接口（依赖倒置）
class IUserRepository {
public:
    virtual ~IUserRepository() = default;
    virtual User findById(int id) = 0;
    virtual void save(const User& user) = 0;
};

// ========== Application Layer ==========
// 应用服务（编排业务流程）
class UserService {
    IUserRepository* userRepo_;
    
public:
    UserService(IUserRepository* repo) : userRepo_(repo) {}
    
    void changeUserEmail(int userId, const std::string& newEmail) {
        // 编排领域对象完成业务流程
        User user = userRepo_->findById(userId);
        user.changeEmail(newEmail);  // 领域逻辑
        userRepo_->save(user);       // 持久化
    }
};

// ========== Infrastructure Layer ==========
// 基础设施实现（具体技术细节）
class MySQLUserRepository : public IUserRepository {
    DatabaseConnection* conn_;
    
public:
    User findById(int id) override {
        // SQL查询
        auto result = conn_->query("SELECT * FROM users WHERE id = ?", id);
        return mapToUser(result);
    }
    
    void save(const User& user) override {
        // SQL更新
        conn_->execute("UPDATE users SET email = ? WHERE id = ?", 
                       user.getEmail(), user.getId());
    }
};

// ========== Presentation Layer ==========
// API控制器
class UserController {
    UserService* userService_;
    
public:
    void handleChangeEmailRequest(HttpRequest& req, HttpResponse& res) {
        int userId = req.getParam<int>("userId");
        std::string newEmail = req.getBody("email");
        
        try {
            userService_->changeUserEmail(userId, newEmail);
            res.sendSuccess("Email changed");
        } catch (const std::exception& e) {
            res.sendError(e.what());
        }
    }
};
```

**分层架构的关键规则：**

| 规则 | 说明 | 示例 |
|------|------|------|
| **单向依赖** | 只能调用下层，不能反向 | UI→Application→Domain |
| **跨层禁止** | 不能跳过中间层 | UI不能直接调用Domain |
| **接口隔离** | 层间通过接口交互 | Domain定义IRepository |
| **依赖倒置** | Domain不依赖Infrastructure | Infrastructure实现Domain的接口 |

---

### 2. 六边形架构（Hexagonal / Ports & Adapters）

```
┌─────────────────────────────────────────────────────────────┐
│                   六边形架构（洋葱架构）                      │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│                         ╔════════╗                           │
│                      ╔══╣ Adapters ╠══╗                      │
│                    ╔═╝  ╚════════╝  ╚═╗                     │
│                  ╔═╝                  ╚═╗                   │
│               UI Adapter            DB Adapter               │
│             REST API             PostgreSQL Impl             │
│                  ║                      ║                    │
│                  ║   ┌──────────────┐  ║                    │
│                  ╠═══│  Port (Interface) │═══╣              │
│                  ║   └──────────────┘  ║                    │
│                  ║                      ║                    │
│                  ║   ┌──────────────┐  ║                    │
│                  ║   │    Domain    │  ║                    │
│                  ║   │     Core     │  ║                    │
│                  ║   │  (完全独立)  │  ║                    │
│                  ║   └──────────────┘  ║                    │
│                  ║                      ║                    │
│               Message            File System                 │
│               Adapter            Adapter                     │
│                  ╚═╗                  ╔═╝                   │
│                    ╚═╗  ╔════════╗  ╔═╝                     │
│                      ╚══╣ Adapters ╠══╝                      │
│                         ╚════════╝                           │
│                                                              │
│  核心理念：                                                   │
│  1. 核心领域完全独立，不依赖外部                              │
│  2. 外部通过端口(Port/Interface)接入                         │
│  3. 适配器(Adapter)实现端口，连接具体技术                     │
│  4. 任何外部交互都是对称的（输入/输出）                       │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**代码示例：**

```cpp
// ========== Core Domain (中心) ==========
// 核心领域模型（完全独立）
class Order {
    int id_;
    std::vector<OrderItem> items_;
    OrderStatus status_;
    
public:
    void addItem(const OrderItem& item) {
        if (status_ != OrderStatus::Draft) {
            throw std::logic_error("Cannot modify confirmed order");
        }
        items_.push_back(item);
    }
    
    void confirm() {
        if (items_.empty()) {
            throw std::logic_error("Cannot confirm empty order");
        }
        status_ = OrderStatus::Confirmed;
    }
    
    double calculateTotal() const {
        double total = 0;
        for (const auto& item : items_) {
            total += item.getPrice() * item.getQuantity();
        }
        return total;
    }
};

// ========== Ports (输入端口) ==========
// 定义核心需要的外部服务接口
class IOrderRepository {  // 输出端口
public:
    virtual ~IOrderRepository() = default;
    virtual void save(const Order& order) = 0;
    virtual Order findById(int id) = 0;
};

class IPaymentGateway {  // 输出端口
public:
    virtual ~IPaymentGateway() = default;
    virtual PaymentResult charge(double amount, const PaymentMethod& method) = 0;
};

class IEmailService {  // 输出端口
public:
    virtual ~IEmailService() = default;
    virtual void sendOrderConfirmation(const Order& order) = 0;
};

// 应用服务（Use Case）
class PlaceOrderUseCase {  // 输入端口的实现
    IOrderRepository* orderRepo_;
    IPaymentGateway* paymentGateway_;
    IEmailService* emailService_;
    
public:
    PlaceOrderUseCase(IOrderRepository* repo, 
                      IPaymentGateway* payment,
                      IEmailService* email)
        : orderRepo_(repo), paymentGateway_(payment), emailService_(email) {}
    
    void execute(int orderId, const PaymentMethod& paymentMethod) {
        // 纯业务逻辑，不依赖具体技术
        Order order = orderRepo_->findById(orderId);
        
        double total = order.calculateTotal();
        auto result = paymentGateway_->charge(total, paymentMethod);
        
        if (result.isSuccess()) {
            order.confirm();
            orderRepo_->save(order);
            emailService_->sendOrderConfirmation(order);
        } else {
            throw std::runtime_error("Payment failed");
        }
    }
};

// ========== Adapters (外围) ==========
// REST API适配器（输入适配器）
class RestOrderController {
    PlaceOrderUseCase* placeOrderUseCase_;
    
public:
    void handlePlaceOrderRequest(HttpRequest& req, HttpResponse& res) {
        int orderId = req.getParam<int>("orderId");
        PaymentMethod payment = parsePaymentMethod(req.getBody());
        
        try {
            placeOrderUseCase_->execute(orderId, payment);
            res.sendJson({{"success", true}});
        } catch (const std::exception& e) {
            res.sendError(e.what());
        }
    }
};

// 数据库适配器（输出适配器）
class PostgreSQLOrderRepository : public IOrderRepository {
    PGConnection* conn_;
    
public:
    void save(const Order& order) override {
        // PostgreSQL具体实现
        conn_->execute("UPDATE orders SET status = ? WHERE id = ?", ...);
    }
    
    Order findById(int id) override {
        auto result = conn_->query("SELECT * FROM orders WHERE id = ?", id);
        return mapToOrder(result);
    }
};

// 支付网关适配器（输出适配器）
class StripePaymentGateway : public IPaymentGateway {
    StripeAPI* api_;
    
public:
    PaymentResult charge(double amount, const PaymentMethod& method) override {
        // Stripe API调用
        return api_->createCharge(amount, method.getToken());
    }
};

// 邮件服务适配器（输出适配器）
class SendGridEmailService : public IEmailService {
    SendGridAPI* api_;
    
public:
    void sendOrderConfirmation(const Order& order) override {
        // SendGrid API调用
        api_->send(buildConfirmationEmail(order));
    }
};

// ========== Main (组装) ==========
int main() {
    // 创建适配器
    PostgreSQLOrderRepository orderRepo(pgConnection);
    StripePaymentGateway paymentGateway(stripeApi);
    SendGridEmailService emailService(sendGridApi);
    
    // 注入核心
    PlaceOrderUseCase placeOrder(&orderRepo, &paymentGateway, &emailService);
    
    // 创建输入适配器
    RestOrderController controller(&placeOrder);
    
    // 启动服务器
    server.route("/orders/:orderId/place", &controller);
}
```

**六边形架构的优势：**

| 特性 | 说明 | 好处 |
|------|------|------|
| **核心独立** | Domain不依赖任何框架 | 可独立测试、演化 |
| **适配器可替换** | 轻松切换技术栈 | 从REST→gRPC无需改核心 |
| **端口对称** | 输入输出一视同仁 | 架构统一清晰 |
| **测试友好** | 所有端口可Mock | 单元测试覆盖率高 |

---

### 3. 事件驱动架构（Event-Driven Architecture）

```
┌─────────────────────────────────────────────────────────────┐
│                  事件驱动架构模式                             │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   ┌─────────┐                       ┌─────────┐            │
│   │ Service │ ──Publish Event──→    │  Event  │            │
│   │    A    │                       │   Bus   │            │
│   └─────────┘                       │ (中介)  │            │
│                                     └────┬────┘            │
│                                          │                  │
│                          Subscribe       │ Subscribe        │
│                          ┌───────────────┼─────────┐       │
│                          ↓               ↓         ↓       │
│                    ┌─────────┐    ┌─────────┐ ┌─────────┐ │
│                    │ Service │    │ Service │ │ Service │ │
│                    │    B    │    │    C    │ │    D    │ │
│                    └─────────┘    └─────────┘ └─────────┘ │
│                                                              │
│  特点：                                                       │
│  1. 发布者不知道订阅者                                        │
│  2. 订阅者不知道发布者                                        │
│  3. 异步通信，解耦时间和空间                                  │
│  4. 易于水平扩展                                             │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**代码示例：**

```cpp
// ========== Event定义 ==========
struct Event {
    std::string type;
    std::string payload;  // JSON或序列化数据
    std::chrono::system_clock::time_point timestamp;
};

struct OrderPlacedEvent : public Event {
    int orderId;
    double amount;
    std::string customerId;
    
    OrderPlacedEvent(int id, double amt, const std::string& custId) 
        : orderId(id), amount(amt), customerId(custId) {
        type = "OrderPlaced";
        timestamp = std::chrono::system_clock::now();
    }
};

// ========== Event Bus ==========
class EventBus {
    using Handler = std::function<void(const Event&)>;
    std::unordered_map<std::string, std::vector<Handler>> subscribers_;
    std::mutex mutex_;
    
public:
    void subscribe(const std::string& eventType, Handler handler) {
        std::lock_guard<std::mutex> lock(mutex_);
        subscribers_[eventType].push_back(handler);
    }
    
    void publish(const Event& event) {
        std::lock_guard<std::mutex> lock(mutex_);
        
        auto it = subscribers_.find(event.type);
        if (it != subscribers_.end()) {
            for (const auto& handler : it->second) {
                // 异步执行（可用线程池）
                std::thread([handler, event]() {
                    handler(event);
                }).detach();
            }
        }
    }
};

// ========== Services ==========
// 订单服务（发布事件）
class OrderService {
    EventBus* eventBus_;
    
public:
    OrderService(EventBus* bus) : eventBus_(bus) {}
    
    void placeOrder(const Order& order) {
        // 处理订单...
        
        // 发布事件
        OrderPlacedEvent event(order.getId(), 
                               order.getTotal(), 
                               order.getCustomerId());
        eventBus_->publish(event);
        
        std::cout << "Order service: Order placed\n";
    }
};

// 库存服务（订阅事件）
class InventoryService {
public:
    void handleOrderPlaced(const Event& event) {
        auto& orderEvent = static_cast<const OrderPlacedEvent&>(event);
        
        std::cout << "Inventory service: Reserving items for order " 
                  << orderEvent.orderId << "\n";
        
        // 预留库存...
    }
};

// 邮件服务（订阅事件）
class EmailService {
public:
    void handleOrderPlaced(const Event& event) {
        auto& orderEvent = static_cast<const OrderPlacedEvent&>(event);
        
        std::cout << "Email service: Sending confirmation to customer " 
                  << orderEvent.customerId << "\n";
        
        // 发送邮件...
    }
};

// 统计服务（订阅事件）
class AnalyticsService {
public:
    void handleOrderPlaced(const Event& event) {
        auto& orderEvent = static_cast<const OrderPlacedEvent&>(event);
        
        std::cout << "Analytics service: Recording sale of $" 
                  << orderEvent.amount << "\n";
        
        // 记录统计...
    }
};

// ========== 组装 ==========
int main() {
    EventBus eventBus;
    
    // 创建服务
    OrderService orderService(&eventBus);
    InventoryService inventoryService;
    EmailService emailService;
    AnalyticsService analyticsService;
    
    // 订阅事件
    eventBus.subscribe("OrderPlaced", [&](const Event& e) {
        inventoryService.handleOrderPlaced(e);
    });
    
    eventBus.subscribe("OrderPlaced", [&](const Event& e) {
        emailService.handleOrderPlaced(e);
    });
    
    eventBus.subscribe("OrderPlaced", [&](const Event& e) {
        analyticsService.handleOrderPlaced(e);
    });
    
    // 下单（触发级联事件）
    Order order(123, "customer-456");
    orderService.placeOrder(order);
    
    // 输出：
    // Order service: Order placed
    // Inventory service: Reserving items for order 123
    // Email service: Sending confirmation to customer customer-456
    // Analytics service: Recording sale of $99.99
    
    // 注意：三个订阅者异步并行执行！
}
```

**事件驱动的优势与挑战：**

| 维度 | 优势 | 挑战 |
|------|------|------|
| **耦合** | 发布者与订阅者完全解耦 | 难以追踪事件流 |
| **扩展** | 添加新订阅者无需修改发布者 | 事件版本管理 |
| **性能** | 异步并行处理 | 事件顺序保证 |
| **测试** | 可独立测试每个服务 | 端到端测试复杂 |
| **调试** | | 分布式追踪困难 |

**防止事件循环依赖：**

```
❌ 错误：A发事件→B处理→B直接调用A
    形成隐式循环依赖

✓ 正确：A发事件E1→B处理→B发事件E2→A订阅E2
    通过事件解耦，显式异步流程
```

---

## 🎨 第四部分：11个最实用的设计模式

### 设计模式分类与选择

```
┌─────────────────────────────────────────────────────────────┐
│              设计模式三大类别                                 │
├──────────────┬──────────────────────────────────────────────┤
│  创建型      │ 解决对象创建问题                              │
│  (Creational)│ Singleton, Factory, Builder                  │
├──────────────┼──────────────────────────────────────────────┤
│  结构型      │ 解决对象组合问题                              │
│  (Structural)│ Adapter, Decorator, Proxy, Flyweight         │
├──────────────┼──────────────────────────────────────────────┤
│  行为型      │ 解决对象协作问题                              │
│  (Behavioral)│ Strategy, Observer, Command, Template Method │
└──────────────┴──────────────────────────────────────────────┘
```

### 问题 → 模式映射表

| 代码异味/问题信号 | 推荐模式 | 解决方案 |
|-------------------|----------|----------|
| 大量if-else分支判断类型/策略 | **Strategy** | 封装算法族，可互换 |
| 根据状态不同行为大量分支 | **State** (策略变体) | 封装状态，状态自管理 |
| 对象创建分散复杂 | **Factory** | 集中创建逻辑 |
| 复杂对象分步构建 | **Builder** | 分离构建过程 |
| 需要全局唯一实例 | **Singleton** | 控制实例数量 |
| 接口不匹配需要适配 | **Adapter** | 转换接口 |
| 运行时动态添加功能 | **Decorator** | 包装增强 |
| 控制对象访问 | **Proxy** | 代理访问 |
| 大量细粒度对象占用内存 | **Flyweight** | 共享对象 |
| 一对多依赖通知 | **Observer** | 发布-订阅 |
| 请求需要排队/撤销/日志 | **Command** | 封装请求为对象 |
| 算法骨架固定，步骤可变 | **Template Method** | 定义骨架，延迟步骤 |

---

### 1. Strategy 策略模式（⭐⭐⭐⭐⭐）

**问题信号：**
```cpp
// ❌ 大量if-else判断算法类型
void processPayment(const std::string& type, double amount) {
    if (type == "CREDIT_CARD") {
        // 信用卡逻辑
    } else if (type == "PAYPAL") {
        // PayPal逻辑
    } else if (type == "ALIPAY") {
        // 支付宝逻辑
    }
    // 每增加一种支付方式就要修改这里 ❌
}
```

**解决方案：**
```cpp
// 策略接口
class PaymentStrategy {
public:
    virtual ~PaymentStrategy() = default;
    virtual void pay(double amount) = 0;
};

// 具体策略
class CreditCardStrategy : public PaymentStrategy {
    void pay(double amount) override {
        std::cout << "Credit Card: $" << amount << "\n";
    }
};

class PayPalStrategy : public PaymentStrategy {
    void pay(double amount) override {
        std::cout << "PayPal: $" << amount << "\n";
    }
};

class AlipayStrategy : public PaymentStrategy {
    void pay(double amount) override {
        std::cout << "Alipay: ¥" << amount * 7.0 << "\n";
    }
};

// 上下文类
class PaymentProcessor {
    PaymentStrategy* strategy_;
public:
    void setStrategy(PaymentStrategy* s) { strategy_ = s; }
    
    void process(double amount) {
        if (strategy_) {
            strategy_->pay(amount);
        }
    }
};

// 使用
CreditCardStrategy creditCard;
PaymentProcessor processor;
processor.setStrategy(&creditCard);
processor.process(100.0);  // 运行时切换算法

// ✅ 新增支付方式：只需添加新策略类，无需修改现有代码
```

**何时使用：**
- ✅ 多个算法可互换
- ✅ 需要运行时切换算法
- ✅ 消除条件判断

**注意事项：**
- ⚠️ 客户端需要知道所有策略
- ⚠️ 策略数量不宜过多

---

### 2. Observer 观察者模式（⭐⭐⭐⭐⭐）

**问题信号：**
```cpp
// ❌ 紧耦合的通知机制
class DataModel {
    View* view1_;
    View* view2_;
    Chart* chart_;
    
    void updateData(int newData) {
        data_ = newData;
        view1_->refresh();  // 直接调用
        view2_->refresh();
        chart_->redraw();
        // 每次新增观察者都要修改这里 ❌
    }
};
```

**解决方案：**
```cpp
// 观察者接口
class Observer {
public:
    virtual ~Observer() = default;
    virtual void update(int data) = 0;
};

// 主题（被观察者）
class Subject {
    std::vector<Observer*> observers_;
    int state_;
    
public:
    void attach(Observer* obs) {
        observers_.push_back(obs);
    }
    
    void detach(Observer* obs) {
        observers_.erase(
            std::remove(observers_.begin(), observers_.end(), obs),
            observers_.end()
        );
    }
    
    void setState(int newState) {
        state_ = newState;
        notify();
    }
    
    int getState() const { return state_; }
    
private:
    void notify() {
        for (auto* obs : observers_) {
            obs->update(state_);
        }
    }
};

// 具体观察者
class TextView : public Observer {
    std::string name_;
public:
    TextView(const std::string& name) : name_(name) {}
    
    void update(int data) override {
        std::cout << name_ << " received: " << data << "\n";
    }
};

class ChartView : public Observer {
    void update(int data) override {
        std::cout << "Chart updated with: " << data << "\n";
    }
};

// 使用
Subject subject;
TextView view1("View1"), view2("View2");
ChartView chart;

subject.attach(&view1);
subject.attach(&view2);
subject.attach(&chart);

subject.setState(42);  // 自动通知所有观察者
// 输出：
// View1 received: 42
// View2 received: 42
// Chart updated with: 42

// ✅ 新增观察者：只需attach，无需修改Subject
```

**何时使用：**
- ✅ 一对多依赖
- ✅ 对象状态变化需通知其他对象
- ✅ 事件驱动系统

**注意事项：**
- ⚠️ 可能导致级联更新
- ⚠️ 需防止内存泄漏（及时detach）

---

### 3. Factory Method 工厂方法（⭐⭐⭐⭐）

**问题信号：**
```cpp
// ❌ 创建逻辑散落各处
Shape* createShape(const std::string& type) {
    if (type == "circle") {
        return new Circle();
    } else if (type == "rectangle") {
        return new Rectangle();
    }
    // 每个创建点都要这样写 ❌
}
```

**解决方案：**
```cpp
// 产品接口
class Shape {
public:
    virtual ~Shape() = default;
    virtual void draw() const = 0;
};

// 具体产品
class Circle : public Shape {
    void draw() const override {
        std::cout << "Drawing Circle\n";
    }
};

class Rectangle : public Shape {
    void draw() const override {
        std::cout << "Drawing Rectangle\n";
    }
};

// 工厂接口
class ShapeFactory {
public:
    virtual ~ShapeFactory() = default;
    virtual Shape* createShape() const = 0;
};

// 具体工厂
class CircleFactory : public ShapeFactory {
    Shape* createShape() const override {
        return new Circle();
    }
};

class RectangleFactory : public ShapeFactory {
    Shape* createShape() const override {
        return new Rectangle();
    }
};

// 或者简单工厂（不够灵活，但实用）
class SimpleShapeFactory {
public:
    static Shape* createShape(const std::string& type) {
        if (type == "circle") return new Circle();
        if (type == "rectangle") return new Rectangle();
        return nullptr;
    }
};

// 使用
auto factory = std::make_unique<CircleFactory>();
Shape* shape = factory->createShape();
shape->draw();
delete shape;

// ✅ 新增形状：添加新Factory类，符合开闭原则
```

**何时使用：**
- ✅ 创建对象类型在运行时确定
- ✅ 隔离对象创建
- ✅ 支持产品族扩展

---

### 4. Builder 建造者模式（⭐⭐⭐⭐）

**问题信号：**
```cpp
// ❌ 构造函数参数过多
class HttpRequest {
public:
    HttpRequest(const std::string& url,
                const std::string& method,
                const std::map<std::string, std::string>& headers,
                const std::string& body,
                int timeout,
                bool followRedirects,
                int maxRedirects) {
        // 参数太多，易出错 ❌
    }
};
```

**解决方案：**
```cpp
// 产品类
class HttpRequest {
    std::string url_;
    std::string method_;
    std::map<std::string, std::string> headers_;
    std::string body_;
    int timeout_;
    bool followRedirects_;
    
    friend class HttpRequestBuilder;
    
public:
    void send() const {
        std::cout << method_ << " " << url_ << "\n";
        // 发送请求...
    }
};

// 建造者
class HttpRequestBuilder {
    HttpRequest request_;
    
public:
    HttpRequestBuilder& setUrl(const std::string& url) {
        request_.url_ = url;
        return *this;
    }
    
    HttpRequestBuilder& setMethod(const std::string& method) {
        request_.method_ = method;
        return *this;
    }
    
    HttpRequestBuilder& addHeader(const std::string& key, 
                                   const std::string& value) {
        request_.headers_[key] = value;
        return *this;
    }
    
    HttpRequestBuilder& setBody(const std::string& body) {
        request_.body_ = body;
        return *this;
    }
    
    HttpRequestBuilder& setTimeout(int timeout) {
        request_.timeout_ = timeout;
        return *this;
    }
    
    HttpRequestBuilder& setFollowRedirects(bool follow) {
        request_.followRedirects_ = follow;
        return *this;
    }
    
    HttpRequest build() {
        // 可在这里做验证
        if (request_.url_.empty()) {
            throw std::invalid_argument("URL is required");
        }
        return request_;
    }
};

// 使用（流式接口）
auto request = HttpRequestBuilder()
    .setUrl("https://api.example.com/users")
    .setMethod("POST")
    .addHeader("Content-Type", "application/json")
    .addHeader("Authorization", "Bearer token123")
    .setBody(R"({"name": "John"})")
    .setTimeout(5000)
    .setFollowRedirects(true)
    .build();

request.send();

// ✅ 可读性强，参数可选，易于扩展
```

**何时使用：**
- ✅ 对象包含多个可选参数
- ✅ 构建过程分步骤
- ✅ 需要验证构建参数

---

### 5. Singleton 单例模式（⭐⭐⭐）

**问题信号：**
```cpp
// ❌ 多处创建日志实例，浪费资源
Logger logger1;
Logger logger2;  // 应该共享同一实例
```

**解决方案（线程安全）：**
```cpp
// C++11 Meyers' Singleton（推荐）
class Logger {
    Logger() = default;  // 私有构造
    
public:
    // 删除拷贝和赋值
    Logger(const Logger&) = delete;
    Logger& operator=(const Logger&) = delete;
    
    static Logger& getInstance() {
        static Logger instance;  // C++11保证线程安全
        return instance;
    }
    
    void log(const std::string& message) {
        std::cout << "[LOG] " << message << "\n";
    }
};

// 使用
Logger::getInstance().log("Application started");
Logger::getInstance().log("Processing request");

// ✅ 全局唯一实例，延迟初始化，线程安全
```

**双重检查锁定版本（C++11前）：**
```cpp
class Singleton {
    static std::atomic<Singleton*> instance_;
    static std::mutex mutex_;
    
    Singleton() = default;
    
public:
    static Singleton* getInstance() {
        Singleton* tmp = instance_.load(std::memory_order_acquire);
        if (tmp == nullptr) {
            std::lock_guard<std::mutex> lock(mutex_);
            tmp = instance_.load(std::memory_order_relaxed);
            if (tmp == nullptr) {
                tmp = new Singleton();
                instance_.store(tmp, std::memory_order_release);
            }
        }
        return tmp;
    }
};
```

**何时使用：**
- ✅ 全局只需一个实例（日志、配置、缓存）
- ✅ 需要全局访问点
- ✅ 延迟初始化

**注意事项：**
- ⚠️ 可能成为全局状态，增加耦合
- ⚠️ 单元测试困难
- ⚠️ 多线程需考虑线程安全

---

### 6. Adapter 适配器模式（⭐⭐⭐⭐）

**问题信号：**
```cpp
// ❌ 第三方库接口不兼容
class LegacyPrinter {
public:
    void printDocument(const char* text) {
        std::cout << "Printing: " << text << "\n";
    }
};

// 现有接口期望
class IPrinter {
public:
    virtual void print(const std::string& content) = 0;
};
```

**解决方案：**
```cpp
// 适配器：将LegacyPrinter适配到IPrinter接口
class PrinterAdapter : public IPrinter {
    LegacyPrinter* legacy_;
    
public:
    PrinterAdapter(LegacyPrinter* legacy) : legacy_(legacy) {}
    
    void print(const std::string& content) override {
        // 转换接口
        legacy_->printDocument(content.c_str());
    }
};

// 使用
LegacyPrinter legacyPrinter;
IPrinter* adapter = new PrinterAdapter(&legacyPrinter);
adapter->print("Hello, World!");  // 统一接口

// ✅ 不修改现有代码，使不兼容接口协同工作
```

**何时使用：**
- ✅ 使用第三方库/遗留代码
- ✅ 接口不匹配
- ✅ 复用现有类但接口不符

---

### 7. Decorator 装饰者模式（⭐⭐⭐⭐）

**问题信号：**
```cpp
// ❌ 功能组合导致子类爆炸
class Window { };
class ScrollableWindow : public Window { };
class BorderedWindow : public Window { };
class ScrollableBorderedWindow : public ScrollableWindow { };
// N个功能 → 2^N 个子类 ❌
```

**解决方案：**
```cpp
// 组件接口
class Component {
public:
    virtual ~Component() = default;
    virtual void render() const = 0;
};

// 具体组件
class TextView : public Component {
public:
    void render() const override {
        std::cout << "[TextView Content]";
    }
};

// 装饰者基类
class Decorator : public Component {
protected:
    Component* component_;
    
public:
    Decorator(Component* comp) : component_(comp) {}
    
    void render() const override {
        if (component_) {
            component_->render();
        }
    }
};

// 具体装饰者
class BorderDecorator : public Decorator {
public:
    BorderDecorator(Component* comp) : Decorator(comp) {}
    
    void render() const override {
        std::cout << "┌─────────┐\n│ ";
        Decorator::render();
        std::cout << " │\n└─────────┘";
    }
};

class ScrollbarDecorator : public Decorator {
public:
    ScrollbarDecorator(Component* comp) : Decorator(comp) {}
    
    void render() const override {
        Decorator::render();
        std::cout << " [▲▼]";
    }
};

// 使用：动态叠加功能
Component* text = new TextView();
Component* bordered = new BorderDecorator(text);
Component* scrollable = new ScrollbarDecorator(bordered);

scrollable->render();
// 输出：
// ┌─────────┐
// │ [TextView Content] │ [▲▼]
// └─────────┘

// ✅ N个功能只需N个装饰类，灵活组合
```

**何时使用：**
- ✅ 动态添加/撤销功能
- ✅ 避免子类爆炸
- ✅ 功能组合灵活

---

### 8. Proxy 代理模式（⭐⭐⭐）

**问题信号：**
```cpp
// ❌ 直接访问昂贵资源
class ExpensiveImage {
public:
    ExpensiveImage(const std::string& filename) {
        loadFromDisk(filename);  // 耗时操作
    }
    void display() { /* ... */ }
};

// 即使不display也会立即加载 ❌
```

**解决方案（虚代理 - 延迟加载）：**
```cpp
class IImage {
public:
    virtual ~IImage() = default;
    virtual void display() = 0;
};

class RealImage : public IImage {
    std::string filename_;
    std::vector<byte> data_;
    
public:
    RealImage(const std::string& filename) : filename_(filename) {
        loadFromDisk();
    }
    
    void display() override {
        std::cout << "Displaying " << filename_ << "\n";
    }
    
private:
    void loadFromDisk() {
        std::cout << "Loading " << filename_ << " from disk...\n";
        // 耗时的磁盘I/O
    }
};

class ImageProxy : public IImage {
    std::string filename_;
    mutable RealImage* realImage_ = nullptr;  // 延迟加载
    
public:
    ImageProxy(const std::string& filename) : filename_(filename) {}
    
    ~ImageProxy() { delete realImage_; }
    
    void display() override {
        if (!realImage_) {
            realImage_ = new RealImage(filename_);  // 真正使用时才加载
        }
        realImage_->display();
    }
};

// 使用
IImage* image = new ImageProxy("large_photo.jpg");
// 此时还未加载图片 ✓

// ...

image->display();  // 现在才加载
// 输出：
// Loading large_photo.jpg from disk...
// Displaying large_photo.jpg
```

**其他代理类型：**
```cpp
// 保护代理：控制访问权限
class ProtectionProxy : public IDocument {
    RealDocument* doc_;
    User* currentUser_;
    
public:
    void edit() override {
        if (currentUser_->hasPermission("WRITE")) {
            doc_->edit();
        } else {
            throw std::runtime_error("Permission denied");
        }
    }
};

// 远程代理：代表远程对象
class RemoteServiceProxy : public IService {
    std::string serverUrl_;
    
public:
    Result call(const Request& req) override {
        // 通过网络调用远程服务
        return httpClient_.post(serverUrl_, req.toJson());
    }
};
```

**何时使用：**
- ✅ 延迟加载（虚代理）
- ✅ 访问控制（保护代理）
- ✅ 远程调用（远程代理）
- ✅ 智能引用（计数、日志）

---

### 9. Flyweight 享元模式（⭐⭐⭐）

**问题信号：**
```cpp
// ❌ 大量相似对象占用内存
class Character {
    char symbol_;
    std::string font_;      // 重复数据
    int fontSize_;          // 重复数据
    std::string color_;     // 重复数据
    int x_, y_;             // 独特数据
};

// 100万个字符 → 大量重复的font/fontSize/color ❌
```

**解决方案：**
```cpp
// 享元：共享的内部状态
class CharacterFlyweight {
    char symbol_;
    std::string font_;
    int fontSize_;
    std::string color_;
    
public:
    CharacterFlyweight(char symbol, const std::string& font, 
                       int size, const std::string& color)
        : symbol_(symbol), font_(font), fontSize_(size), color_(color) {}
    
    void render(int x, int y) const {  // 外部状态通过参数传入
        std::cout << "Rendering '" << symbol_ << "' at (" 
                  << x << "," << y << ") "
                  << "font=" << font_ << " size=" << fontSize_ << "\n";
    }
};

// 享元工厂：管理共享对象
class FlyweightFactory {
    std::map<std::string, CharacterFlyweight*> flyweights_;
    
public:
    CharacterFlyweight* getFlyweight(char symbol, const std::string& font,
                                      int size, const std::string& color) {
        std::string key = std::string(1, symbol) + font + 
                          std::to_string(size) + color;
        
        if (flyweights_.find(key) == flyweights_.end()) {
            flyweights_[key] = new CharacterFlyweight(symbol, font, size, color);
        }
        
        return flyweights_[key];
    }
    
    ~FlyweightFactory() {
        for (auto& pair : flyweights_) {
            delete pair.second;
        }
    }
};

// 使用
FlyweightFactory factory;

// 100万个'A'，但只创建一个Flyweight对象
for (int i = 0; i < 1000000; ++i) {
    auto* flyweight = factory.getFlyweight('A', "Arial", 12, "Black");
    flyweight->render(i % 800, i / 800);  // 外部状态（位置）不同
}

// ✅ 内存占用大幅降低：1个对象 vs 100万个对象
```

**何时使用：**
- ✅ 大量相似对象
- ✅ 对象大部分状态可共享
- ✅ 内存优化

**注意事项：**
- ⚠️ 区分内部状态（共享）和外部状态（独特）
- ⚠️ 需要工厂管理

---

### 10. Command 命令模式（⭐⭐⭐）

**问题信号：**
```cpp
// ❌ 请求和执行紧耦合
button.onClick([]() {
    document.save();  // 直接调用
});

// 无法撤销、无法排队、无法日志 ❌
```

**解决方案：**
```cpp
// 命令接口
class Command {
public:
    virtual ~Command() = default;
    virtual void execute() = 0;
    virtual void undo() = 0;
};

// 接收者
class Document {
    std::string content_;
    
public:
    void insertText(const std::string& text) {
        content_ += text;
        std::cout << "Inserted: " << text << "\n";
    }
    
    void deleteText(size_t count) {
        if (content_.size() >= count) {
            content_.erase(content_.size() - count);
            std::cout << "Deleted " << count << " chars\n";
        }
    }
    
    std::string getContent() const { return content_; }
};

// 具体命令
class InsertTextCommand : public Command {
    Document* doc_;
    std::string text_;
    
public:
    InsertTextCommand(Document* doc, const std::string& text)
        : doc_(doc), text_(text) {}
    
    void execute() override {
        doc_->insertText(text_);
    }
    
    void undo() override {
        doc_->deleteText(text_.size());
    }
};

class DeleteTextCommand : public Command {
    Document* doc_;
    size_t count_;
    std::string deletedText_;  // 保存用于undo
    
public:
    DeleteTextCommand(Document* doc, size_t count)
        : doc_(doc), count_(count) {}
    
    void execute() override {
        deletedText_ = doc_->getContent().substr(
            doc_->getContent().size() - count_
        );
        doc_->deleteText(count_);
    }
    
    void undo() override {
        doc_->insertText(deletedText_);
    }
};

// 调用者（支持撤销）
class TextEditor {
    std::vector<Command*> history_;
    int current_ = -1;
    
public:
    void executeCommand(Command* cmd) {
        cmd->execute();
        
        // 清除redo历史
        while (history_.size() > current_ + 1) {
            delete history_.back();
            history_.pop_back();
        }
        
        history_.push_back(cmd);
        current_++;
    }
    
    void undo() {
        if (current_ >= 0) {
            history_[current_]->undo();
            current_--;
        }
    }
    
    void redo() {
        if (current_ < (int)history_.size() - 1) {
            current_++;
            history_[current_]->execute();
        }
    }
};

// 使用
Document doc;
TextEditor editor;

editor.executeCommand(new InsertTextCommand(&doc, "Hello "));
editor.executeCommand(new InsertTextCommand(&doc, "World"));
// 输出：Inserted: Hello 
//      Inserted: World

editor.undo();
// 输出：Deleted 5 chars

editor.redo();
// 输出：Inserted: World

// ✅ 支持撤销/重做、命令队列、宏命令
```

**何时使用：**
- ✅ 需要撤销/重做
- ✅ 命令排队执行
- ✅ 日志记录操作
- ✅ 事务系统

---

### 11. Template Method 模板方法（⭐⭐⭐）

**问题信号：**
```cpp
// ❌ 相似流程代码重复
void processOrder() {
    validate();
    calculate();
    save();
    sendEmail();
}

void processReturn() {
    validate();
    calculate();  // 相同
    refund();     // 不同
    sendEmail();  // 相同
}
// 大量重复代码 ❌
```

**解决方案：**
```cpp
// 抽象基类定义算法骨架
class OrderProcessor {
public:
    // 模板方法：定义算法骨架
    void process() {
        validate();
        calculate();
        executeSpecificLogic();  // 延迟到子类
        sendNotification();
    }
    
protected:
    void validate() {
        std::cout << "Validating order...\n";
    }
    
    void calculate() {
        std::cout << "Calculating totals...\n";
    }
    
    void sendNotification() {
        std::cout << "Sending notification...\n";
    }
    
    // 钩子方法：子类实现
    virtual void executeSpecificLogic() = 0;
};

// 具体类实现变化的步骤
class NewOrderProcessor : public OrderProcessor {
protected:
    void executeSpecificLogic() override {
        std::cout << "Creating new order in database\n";
    }
};

class ReturnOrderProcessor : public OrderProcessor {
protected:
    void executeSpecificLogic() override {
        std::cout << "Processing refund\n";
    }
};

// 使用
OrderProcessor* processor = new NewOrderProcessor();
processor->process();
// 输出：
// Validating order...
// Calculating totals...
// Creating new order in database
// Sending notification...

// ✅ 复用公共逻辑，扩展变化部分
```

**何时使用：**
- ✅ 算法骨架固定
- ✅ 部分步骤可定制
- ✅ 避免代码重复

---

## 🔧 第五部分：质量保障与持续改进

### 并发设计考虑

```
┌─────────────────────────────────────────────────────────────┐
│              并发设计策略                                     │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  1. 数据与行为共定位                                          │
│     ├─ 每个对象管理自己的状态                                 │
│     ├─ 内部封装同步机制（mutex）                              │
│     └─ 不同实例无共享冲突                                     │
│                                                              │
│  2. Actor模型/任务模型                                        │
│     ├─ Actor拥有私有状态                                      │
│     ├─ 通过消息通信                                           │
│     ├─ 不共享内存                                             │
│     └─ 天然并发安全                                           │
│                                                              │
│  3. 不可变对象                                                │
│     ├─ const成员变量                                          │
│     ├─ 无setter方法                                           │
│     ├─ 线程安全（只读）                                       │
│     └─ 避免锁开销                                             │
│                                                              │
│  4. 锁粒度控制                                                │
│     ├─ 细粒度锁（性能好，复杂）                               │
│     ├─ 粗粒度锁（简单，性能差）                               │
│     └─ 无锁数据结构（高级）                                   │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**线程安全的对象示例：**

```cpp
class ThreadSafeCounter {
    std::atomic<int> count_{0};
    
public:
    void increment() {
        count_.fetch_add(1, std::memory_order_relaxed);
    }
    
    int get() const {
        return count_.load(std::memory_order_relaxed);
    }
};

class ThreadSafeQueue {
    std::queue<int> queue_;
    mutable std::mutex mutex_;
    std::condition_variable cv_;
    
public:
    void push(int value) {
        std::lock_guard<std::mutex> lock(mutex_);
        queue_.push(value);
        cv_.notify_one();
    }
    
    int pop() {
        std::unique_lock<std::mutex> lock(mutex_);
        cv_.wait(lock, [this]{ return !queue_.empty(); });
        int value = queue_.front();
        queue_.pop();
        return value;
    }
};
```

---

### 可测试性设计

```
┌─────────────────────────────────────────────────────────────┐
│              测试友好设计原则                                 │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ✓ 所有外部依赖通过接口                                       │
│     → 可Mock/Stub                                            │
│                                                              │
│  ✓ 构造函数注入依赖                                           │
│     → 测试时注入假对象                                        │
│                                                              │
│  ✓ 避免全局状态/单例                                          │
│     → 隔离测试环境                                            │
│                                                              │
│  ✓ 纯函数优先                                                │
│     → 无副作用，易测试                                        │
│                                                              │
│  ✓ 小方法/单一职责                                            │
│     → 测试粒度细                                              │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**测试示例：**

```cpp
// 生产代码
class UserService {
    IDatabase* db_;
    IEmailService* emailService_;
    
public:
    UserService(IDatabase* db, IEmailService* email)
        : db_(db), emailService_(email) {}
    
    void registerUser(const User& user) {
        if (db_->exists(user.getEmail())) {
            throw std::runtime_error("User already exists");
        }
        
        db_->save(user);
        emailService_->sendWelcomeEmail(user.getEmail());
    }
};

// 测试代码
class MockDatabase : public IDatabase {
    bool shouldUserExist = false;
    std::vector<User> savedUsers;
    
public:
    void setShouldUserExist(bool exists) { shouldUserExist = exists; }
    
    bool exists(const std::string& email) override {
        return shouldUserExist;
    }
    
    void save(const User& user) override {
        savedUsers.push_back(user);
    }
    
    size_t getSaveCount() const { return savedUsers.size(); }
};

class MockEmailService : public IEmailService {
    int emailsSent = 0;
    
public:
    void sendWelcomeEmail(const std::string& email) override {
        emailsSent++;
    }
    
    int getEmailsSent() const { return emailsSent; }
};

// 单元测试
void testRegisterNewUser() {
    MockDatabase mockDb;
    MockEmailService mockEmail;
    UserService service(&mockDb, &mockEmail);
    
    User user("test@example.com", "password");
    service.registerUser(user);
    
    assert(mockDb.getSaveCount() == 1);
    assert(mockEmail.getEmailsSent() == 1);
}

void testRegisterExistingUser() {
    MockDatabase mockDb;
    mockDb.setShouldUserExist(true);
    MockEmailService mockEmail;
    UserService service(&mockDb, &mockEmail);
    
    User user("existing@example.com", "password");
    
    try {
        service.registerUser(user);
        assert(false);  // 不应执行到这里
    } catch (const std::runtime_error&) {
        // 预期异常
    }
    
    assert(mockDb.getSaveCount() == 0);  // 未保存
    assert(mockEmail.getEmailsSent() == 0);  // 未发邮件
}
```

---

### 设计检查表

```
┌─────────────────────────────────────────────────────────────┐
│              每次迭代后的设计自检清单                         │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ✅ 模块暴露最小接口了吗？                                    │
│     □ 头文件只暴露必要API                                     │
│     □ 内部实现类型未泄漏                                      │
│     □ 使用Pimpl隐藏私有成员                                   │
│                                                              │
│  ✅ 新需求可以通过"添加"实现吗？                              │
│     □ 无需修改既有类                                          │
│     □ 符合开放-封闭原则                                       │
│     □ 通过策略/插件扩展                                       │
│                                                              │
│  ✅ 跨模块调用可否用Mock隔离测试？                            │
│     □ 所有依赖都是接口                                        │
│     □ 使用依赖注入                                            │
│     □ 单元测试覆盖率>80%                                      │
│                                                              │
│  ✅ 继承层次是否合理？                                        │
│     □ 层级 ≤ 3层                                              │
│     □ 基类有virtual析构函数                                   │
│     □ 满足is-a关系                                            │
│     □ 未仅为复用而继承                                        │
│                                                              │
│  ✅ 组合对象的所有权是否清晰？                                │
│     □ unique_ptr表示唯一所有权                                │
│     □ shared_ptr表示共享所有权                                │
│     □ 原始指针/引用表示借用                                   │
│     □ 遵循RAII原则                                            │
│                                                              │
│  ✅ 核心业务逻辑依赖外部细节了吗？                            │
│     □ Domain层独立于UI                                        │
│     □ Domain层独立于数据库                                    │
│     □ 通过接口访问基础设施                                    │
│                                                              │
│  ✅ 依赖关系有无环路？                                        │
│     □ 依赖图是DAG                                             │
│     □ 使用前向声明减少依赖                                    │
│     □ Include-What-You-Use                                   │
│                                                              │
│  ✅ 并发安全考虑了吗？                                        │
│     □ 识别共享状态                                            │
│     □ 同步机制明确                                            │
│     □ 无竞态条件                                              │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

### 持续演化的三阶段

```
┌─────────────────────────────────────────────────────────────┐
│           从耦合到解耦的演化路径                              │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  阶段1：显化耦合                                              │
│  ├─ 划分领域和模块边界                                        │
│  ├─ 定义明确的接口契约                                        │
│  ├─ 用接口暴露耦合点                                          │
│  └─ 目标：看清依赖关系                                        │
│                                                              │
│  阶段2：削弱耦合                                              │
│  ├─ 应用依赖倒置（DIP）                                       │
│  ├─ 使用策略/装饰模式                                         │
│  ├─ 引入事件总线解耦                                          │
│  ├─ 降低依赖强度（依赖金字塔）                                │
│  └─ 目标：松散连接                                            │
│                                                              │
│  阶段3：消减耦合                                              │
│  ├─ 自动化测试保障                                            │
│  ├─ 持续重构优化                                              │
│  ├─ 移除不必要依赖                                            │
│  ├─ 调整模块边界                                              │
│  └─ 目标：简洁设计                                            │
│                                                              │
│  → 循环往复，持续改进                                         │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

## 📚 核心概念速查表

### 耦合与依赖本质

```
耦合的本质 = 为协同而泄漏的自由度
  高耦合 = 牵一发动全身 ❌
  低耦合 = 插拔式独立 ✓

依赖的本质 = A需要B来完成功能
  强依赖 = 编译时绑定（继承）
  弱依赖 = 运行时绑定（接口）

依赖倒置的本质：
  控制权转移 + 依赖方向改变
  高层 → 抽象 ← 低层
  不稳定 → 稳定 ← 不稳定
```

### 抽象的三个层次

```
【层次1】概念抽象
  "数据库" 是抽象概念
  ├→ MySQL, PostgreSQL, MongoDB
  └→ 共同行为：连接、查询、更新

【层次2】行为抽象
  interface IDatabase {
    connect();    // 抽象行为
    query();      // 不关心怎么做
  }

【层次3】实现隐藏
  class MySQLImpl {
  private:
    MYSQL* conn;  // 外部看不见
    void parseResult();  // 外部看不见
  }
```

---

## 🎓 总结：统一的设计思维

```
┌─────────────────────────────────────────────────────────────┐
│                  设计的一致性原则                             │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  无论是宏观架构还是微观代码                                   │
│  无论是系统设计还是类设计                                     │
│  无论是服务拆分还是函数拆分                                   │
│                                                              │
│  始终遵循相同的核心原则：                                     │
│                                                              │
│  ┌────────────────────────────────────┐                    │
│  │  高内聚：相关的放在一起            │                    │
│  │  低耦合：依赖最小化且可替换        │                    │
│  │  单一职责：一个变化原因            │                    │
│  │  依赖倒置：依赖抽象而非实现        │                    │
│  │  开放封闭：扩展开放，修改封闭      │                    │
│  │  接口隔离：小而专的契约            │                    │
│  └────────────────────────────────────┘                    │
│                                                              │
│  从系统到模块到类到函数                                       │
│  递归应用这些原则                                             │
│  在不同缩放级别保持一致                                       │
│                                                              │
│  这就是统一的设计思维                                         │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**记住：设计是持续演化的过程，而非一次性完成。**

- ✅ 从简单开始
- ✅ 识别问题信号
- ✅ 应用合适模式
- ✅ 持续重构改进
- ✅ 保持代码长青

---

**愿你的代码高内聚、低耦合，系统易扩展、可维护！** 🎯

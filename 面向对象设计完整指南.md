# 🏗️ 面向对象设计完整指南

> **核心理念：高内聚 + 低耦合 = 可扩展、可测试、可维护**

---

## 🔖 快速导航目录

> **提示**：VS Code中按 `Ctrl+点击`（Windows）或 `Cmd+点击`（Mac）可直接跳转

### 核心章节
- [第一部分：三步设计流程（战略层）](#-第一部分三步设计流程战略层)
- [第二部分：依赖控制金字塔（战术层）](#️-第二部分依赖控制金字塔战术层)
- [第三部分：11个最实用设计模式](#-第三部分11个最实用的设计模式)
- [第四部分：质量保障与持续改进](#-第四部分质量保障与持续改进)

### 设计流程
- [Step 1: 划分领域边界](#step-1-划分领域边界--分而治之)
  - [事件风暴识别业务事件](#实践技巧)
  - [按变化原因组织目录](#实践技巧)
  - [纯算法与基础设施分离](#实践技巧)
  - [稳定性分层思维](#实践技巧)
- [Step 2: 定义职责与契约](#step-2-定义职责与契约--模块关系与接口设计)
  - [单一职责原则详解](#三大核心原则)
  - [接口隔离原则详解](#三大核心原则)
  - [依赖倒置原则详解](#三大核心原则)
  - [Orchestrator模式（编排者）](#orchestrator模式编排者模式)
- [Step 3: 逐层细化](#step-3-逐层细化--模块内部设计迭代)

### 依赖与原则
- [依赖金字塔六层级](#依赖关系六层级从弱到强)
  - [Lv-0: 依赖（最弱）](#lv-0-依赖-dependency---最弱-)
  - [Lv-1: 关联](#lv-1-关联-association---弱耦合-)
  - [Lv-2: 实现（推荐）](#lv-2-实现-realization---推荐-)
  - [Lv-3: 聚合](#lv-3-聚合-aggregation---集合关系-)
  - [Lv-4: 组合](#lv-4-组合-composition---强耦合-)
  - [Lv-5: 继承（最强）](#lv-5-继承-inheritance---最强-)
  - [跨边界依赖规则总结](#跨边界依赖规则总结)
- [SOLID五大原则](#solid五大原则完整解析)
  - [S - 单一职责原则](#1-单一职责原则-srp-详解)
    - [职责数量指导](#职责数量指导)
    - [SRP在嵌套职责中的应用](#srp在嵌套职责中的应用)
  - [O - 开放-封闭原则](#2-开放-封闭原则-ocp-详解)
  - [L - 里氏替换原则](#3-里氏替换原则-lsp-详解)
  - [I - 接口隔离原则](#4-接口隔离原则-isp-详解)
  - [D - 依赖倒置原则](#5-依赖倒置原则-dip-深度解析)
    - [跨模块接口位置策略](#跨模块接口位置策略)
- [8项黄金法则](#8项黄金法则总结)
  - [6. 信息隐藏（封装）](#6-信息隐藏封装)
  - [7. 优先组合而非继承](#7-优先组合而非继承)
    - [跨边界继承禁令](#跨边界继承禁令)
  - [8. 资源所有权管理](#8-资源所有权管理c特有)

### 设计模式速查（11个）
- [Strategy 策略模式](#1-strategy-策略模式)
- [Observer 观察者模式](#2-observer-观察者模式)
- [Factory 工厂模式](#3-factory-method-工厂方法)
- [Builder 建造者模式](#4-builder-建造者模式)
- [Singleton 单例模式](#5-singleton-单例模式)
- [Adapter 适配器模式](#6-adapter-适配器模式)
- [Decorator 装饰者模式](#7-decorator-装饰者模式)
- [Proxy 代理模式](#8-proxy-代理模式)
- [Flyweight 享元模式](#9-flyweight-享元模式)
- [Command 命令模式](#10-command-命令模式)
- [Template Method 模板方法](#11-template-method-模板方法)

### 实用工具
- [设计检查表](#设计检查表)
- [核心概念速查表](#核心概念速查表)
- [问题→模式映射表](#问题--模式映射表)

---

## 📋 全文导览地图

```
┌─────────────────────────────────────────────────────────────┐
│                    统一的设计思维                            │
│         从系统架构到代码细节，应用相同的原则                 │
└──────────────────┬──────────────────────────────────────────┘
                   ↓
    ┌──────────────────────────────────────────┐
    │ 第一部分：三步设计流程（战略层）         │
    │   Step 1: 划分领域边界                   │
    │   Step 2: 定义职责与契约                 │
    │   Step 3: 逐层细化设计                   │
    └──────────────┬───────────────────────────┘
                   ↓
    ┌──────────────────────────────────────────┐
    │ 第二部分：依赖控制金字塔（战术层）       │
    │   六层级依赖关系 (Lv-0 → Lv-5)          │
    │   SOLID + 8项黄金法则                    │
    └──────────────┬───────────────────────────┘
                   ↓
    ┌──────────────────────────────────────────┐
    │ 第三部分：设计模式（工具箱）             │
    │   11个最实用的GoF模式                    │
    └──────────────┬───────────────────────────┘
                   ↓
    ┌──────────────────────────────────────────┐
    │ 第四部分：质量保障（持续改进）           │
    │   并发设计 / 测试策略 / 设计检查表       │
    └──────────────────────────────────────────┘
```

---

## 🎯 第一部分：三步设计流程（战略层）

> **一句话精髓**：从业务出发，找到「会变的」，把它隔离出来，让它可替换、可测试。

---

### 🧭 设计的起点：理解业务

**设计不是从代码开始，而是从业务需求开始**：

```
┌─────────────────────────────────────────────────────────────┐
│                     设计的完整流程                           │
│                                                             │
│   业务需求 → 识别概念 → 定义职责 → 处理变化 → 代码实现       │
│      ↓          ↓          ↓          ↓                     │
│   Step 0     Step 0     Step 1    Step 2-3                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

### Step 0: 从业务到设计（最重要的一步）

**拿到需求后，先回答这4个问题**：

| 问题 | 目的 | 产出 |
|------|------|------|
| ① 这个功能要做什么？ | 明确边界 | 一句话描述 |
| ② 涉及哪些核心概念？ | 识别实体 | 名词列表（订单、用户、支付...） |
| ③ 这些概念之间什么关系？ | 理清职责 | 谁拥有谁、谁调用谁 |
| ④ 哪些地方未来可能变化？ | 预判变化 | 变化点列表 |

**示例：订单通知功能**

```
① 做什么：订单完成后通知用户
② 核心概念：订单(Order)、通知(Notification)、用户(User)
③ 关系：订单完成 → 触发通知 → 发送给用户
④ 变化点：通知方式（邮件/短信/微信）、通知内容模板
```

---

### 🔍 Step 0 详解：识别核心概念

**方法：从需求描述中提取名词和动词**

```
需求："用户下单后，系统计算折扣，保存订单，发送确认邮件"

名词（→ 类/实体）        动词（→ 方法/行为）
├─ 用户 User            ├─ 下单 createOrder
├─ 订单 Order           ├─ 计算折扣 calculateDiscount
├─ 折扣 Discount        ├─ 保存 save
└─ 邮件 Email           └─ 发送 send
```

**然后问：谁负责什么？**

| 概念 | 职责 | 对应类 |
|------|------|--------|
| 订单 | 存储订单数据 | Order（数据类） |
| 折扣计算 | 计算折扣金额 | DiscountCalculator |
| 订单存储 | 保存到数据库 | OrderRepository |
| 邮件通知 | 发送邮件 | EmailNotifier |
| 流程编排 | 协调以上步骤 | OrderService |

**产出：初步的类结构**

```cpp
// 从业务概念直接映射出来的类
class Order { /* 订单数据 */ };
class DiscountCalculator { double calculate(Order&); };
class OrderRepository { void save(Order&); };
class EmailNotifier { void send(string email, string msg); };
class OrderService { void createOrder(OrderRequest&); };  // 编排者
```

---

### 🎯 Step 0 之后：判断需要多少设计

**现在才问：哪些地方会变化？**

| 概念 | 会变吗？ | 变化类型 | 需要的设计 |
|------|----------|----------|------------|
| Order | 字段可能增加 | 数据变化 | 普通类即可 |
| DiscountCalculator | 折扣规则会变 | 算法变化 | 可能需要策略模式 |
| OrderRepository | 可能换数据库 | 实现变化 | 需要接口 |
| EmailNotifier | 会加短信/微信 | 多种实现 | 需要接口 |

**根据变化程度，决定用不用 Step 1-3**

---

### 完整设计流程总览

```
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  Step 0: 理解业务                                           │
│  ─────────────────                                          │
│  ① 功能做什么？（一句话）                                    │
│  ② 涉及哪些概念？（名词→类）                                 │
│  ③ 谁负责什么？（动词→方法）                                 │
│  ④ 哪里会变？（变化点列表）                                  │
│                                                             │
│          ↓ 根据变化程度，决定需要多少设计 ↓                  │
│                                                             │
│  Step 1: 分离变化                                           │
│  ─────────────────                                          │
│  把「会变的」和「稳定的」分开放                              │
│                                                             │
│  Step 2: 定义接口                                           │
│  ─────────────────                                          │
│  变化的部分有多种实现？→ 提取接口                            │
│                                                             │
│  Step 3: 依赖注入                                           │
│  ─────────────────                                          │
│  依赖外部系统？→ 构造函数注入，支持测试                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

### 💡 完整案例：从需求到设计

**需求**："用户下单后，计算会员折扣，保存订单，发送通知"

**Step 0: 理解业务**

```
① 做什么：处理用户下单的完整流程
② 核心概念：
   - 用户(User) - 下单的人
   - 订单(Order) - 购买记录
   - 折扣(Discount) - 会员优惠
   - 通知(Notification) - 下单成功提醒
③ 职责划分：
   - OrderService: 编排整个流程
   - DiscountCalculator: 计算折扣
   - OrderRepository: 保存订单
   - Notifier: 发送通知
④ 变化点分析：
   - 折扣规则：可能改变（普通/VIP/节日促销）
   - 存储方式：可能换数据库
   - 通知方式：会加短信、微信
```

**Step 1-3: 根据变化点设计**

```cpp
// 变化点1: 折扣规则会变 → 单独类（暂不需接口，规则不多）
class DiscountCalculator {
public:
    double calculate(const Order& order, const User& user) {
        if (user.isVIP()) return order.total * 0.8;
        return order.total;
    }
};

// 变化点2: 存储方式可能变 → 接口 + 注入
class IOrderRepository {
public:
    virtual void save(const Order& order) = 0;
    virtual ~IOrderRepository() = default;
};

// 变化点3: 通知会有多种 → 接口 + 注入
class INotifier {
public:
    virtual void notify(const User& user, const string& msg) = 0;
    virtual ~INotifier() = default;
};

// 编排者：组合所有组件
class OrderService {
    DiscountCalculator calculator_;  // 直接持有（变化不大）
    IOrderRepository* repo_;          // 注入（会变）
    INotifier* notifier_;             // 注入（会变）
public:
    OrderService(IOrderRepository* r, INotifier* n) 
        : repo_(r), notifier_(n) {}
    
    void createOrder(const User& user, OrderRequest& req) {
        // 流程清晰，职责分明
        Order order = buildOrder(req);
        order.discount = calculator_.calculate(order, user);
        repo_->save(order);
        notifier_->notify(user, "订单" + order.id + "已创建");
    }
};
```

**为什么这样设计？**

| 组件 | 设计决策 | 原因 |
|------|----------|------|
| DiscountCalculator | 普通类 | 规则变化通过修改这一个类即可 |
| IOrderRepository | 接口+注入 | 可能换数据库，需要Mock测试 |
| INotifier | 接口+注入 | 明确会有多种实现，需要Mock测试 |
| OrderService | 编排者 | 只负责流程，不负责具体实现 |

---

### 🎯 快速决策流程

```
拿到需求
    ↓
Step 0: 这是要做什么？涉及哪些概念？谁负责什么？
    ↓
列出变化点
    ↓
┌─────────────────────────────────────────────────┐
│  对每个变化点问：                                │
│                                                 │
│  Q1: 这个会变吗？                               │
│      └─ 不会 → 简单写                           │
│      └─ 会 → 单独成类 (Step 1)                  │
│                                                 │
│  Q2: 会有多种实现吗？                            │
│      └─ 不会 → 普通类即可                        │
│      └─ 会 → 提取接口 (Step 2)                  │
│                                                 │
│  Q3: 依赖外部系统吗？                            │
│      └─ 不 → 直接持有                           │
│      └─ 是 → 必须接口+注入 (Step 2+3)           │
└─────────────────────────────────────────────────┘
```

---

### 🧠 记忆口诀

```
设计四步走：

  零看业务定概念  ← 从需求出发，识别实体和职责
  一问变化分开放  ← 会变的单独成类
  二问替换提接口  ← 多种实现用接口
  三问测试靠注入  ← 外部依赖要注入

不要跳过 Step 0！
```

---

---

## ⚖️ 第二部分：依赖控制金字塔（战术层）

### 依赖关系六层级：从弱到强

```
┌─────────────────────────────────────────────────────────────┐
│                   依赖金字塔结构                              │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│              Lv-5 继承 (Inheritance) 🔴                      │
│             /    最强耦合，谨慎使用    \                      │
│            ────────────────────────────                      │
│          Lv-4 组合 (Composition) 🟠                          │
│         /    生命周期绑定，整体-部分    \                     │
│        ────────────────────────────────                      │
│       Lv-3 聚合 (Aggregation) 🟡                             │
│      /    集合关系，外部拥有所有权     \                      │
│     ──────────────────────────────────                       │
│    Lv-2 实现 (Realization) 🟢                                │
│   /    通过接口，支持替换，★推荐★    \                        │
│  ────────────────────────────────────────                    │
│ Lv-1 关联 (Association) 🔵                                   │
│/    长引用，不控制生命周期           \                        │
│──────────────────────────────────────────                    │
│Lv-0 依赖 (Dependency) ⚪                                      │
│  最弱耦合，临时使用，首选                                     │
│                                                              │
│  🎯 设计原则：                                                │
│  1. 尽量使用最弱的关系满足需求                                │
│  2. 证明必要性后才升级到更强关系                              │
│  3. ⚠️ 跨模块/服务禁用 Lv-4/Lv-5！                           │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

### Lv-0: 依赖 (Dependency) - 最弱 ⚪

```cpp
/**
 * 特征：临时使用，无持久引用
 * 耦合度：⭐ (最低)
 * 适用场景：工具函数、临时计算、参数传递
 */

class ReportGenerator {
public:
    // 通过参数传入，用完即丢
    void generate(const Data& data) {
        int sum = Utils::calculate(data);  // 调用工具函数
        // 使用后不保留引用
    }
    
    // 局部创建，函数结束即销毁
    void process() {
        Parser parser;  // 栈上临时对象
        parser.parse();
    }  // parser自动销毁
};
```

**优势：**
- ✅ 零持久耦合
- ✅ 函数级隔离
- ✅ 易于测试（纯函数）
- ✅ 无生命周期管理负担

**使用建议：**
- 首选此关系！
- 适合：工具类、算法函数、数据转换

---

### Lv-1: 关联 (Association) - 弱耦合 🔵

```cpp
/**
 * 特征：长期引用，但不控制生命周期
 * 耦合度：⭐⭐
 * 适用场景：观察者模式、视图-模型、回调
 */

class Model {
    std::string data;
public:
    std::string getData() const { return data; }
    void setData(const std::string& d) { data = d; }
};

class View {
    const Model* model_;  // 持有指针/引用
    
public:
    View(const Model* m) : model_(m) {}
    
    void update() {
        // 使用model_，但不负责创建/销毁
        std::cout << "显示: " << model_->getData() << "\n";
    }
    
    // ✓ Model在外部管理
    // ✓ View只是观察者
    // ✓ 生命周期独立
};

// 使用示例
int main() {
    Model model;
    View view(&model);  // View关联到Model
    
    model.setData("Hello");
    view.update();  // 显示: Hello
    
    // model和view生命周期独立
    // model销毁时，view也要确保不再访问
}
```

**优势：**
- ✅ 生命周期解耦
- ✅ 多个对象可共享同一引用
- ✅ 适合观察者/监听器模式

**注意事项：**
- ⚠️ 需确保被引用对象仍存在（避免悬空指针）
- ⚠️ 不拥有所有权，不负责delete

---

### Lv-2: 实现 (Realization) - 推荐 🟢

```cpp
/**
 * 特征：通过接口协作，支持替换
 * 耦合度：⭐⭐
 * 适用场景：跨模块依赖的首选方式！
 * 
 * ★★★ 这是实现依赖倒置(DIP)的核心机制 ★★★
 */

// 抽象接口（稳定）
class ICompressor {
public:
    virtual ~ICompressor() = default;
    virtual std::vector<byte> compress(const std::vector<byte>& data) = 0;
};

// 具体实现1
class GzipCompressor : public ICompressor {
    std::vector<byte> compress(const std::vector<byte>& data) override {
        // gzip压缩算法
        return compressedData;
    }
};

// 具体实现2
class LZ4Compressor : public ICompressor {
    std::vector<byte> compress(const std::vector<byte>& data) override {
        // lz4压缩算法
        return compressedData;
    }
};

// 高层模块（依赖接口）
class FileManager {
    ICompressor* compressor_;  // 依赖接口，非实现
    
public:
    // 依赖注入
    void setCompressor(ICompressor* c) { 
        compressor_ = c; 
    }
    
    void saveFile(const std::vector<byte>& data) {
        // 多态调用，运行时决定具体实现
        auto compressed = compressor_->compress(data);
        // 写入文件...
    }
};

// 使用：运行时切换算法
int main() {
    FileManager fm;
    
    GzipCompressor gzip;
    fm.setCompressor(&gzip);
    fm.saveFile(data);  // 使用gzip
    
    LZ4Compressor lz4;
    fm.setCompressor(&lz4);
    fm.saveFile(data);  // 切换到lz4，无需修改FileManager！
}

// 测试：注入Mock
class MockCompressor : public ICompressor {
    std::vector<byte> compress(const std::vector<byte>& data) override {
        return data;  // 不压缩，便于测试
    }
};

void testFileManager() {
    FileManager fm;
    MockCompressor mock;
    fm.setCompressor(&mock);  // 隔离真实压缩逻辑
    // 测试FileManager的其他逻辑...
}
```

**优势：**
- ✅ **依赖倒置（DIP）**：高层不依赖低层
- ✅ **易于测试**：可Mock所有依赖
- ✅ **运行时替换**：热插拔能力
- ✅ **开放-封闭**：添加新实现无需修改调用方

**跨模块依赖的黄金法则：**
```
┌──────────────────────────────────────┐
│   跨模块依赖必须通过接口！            │
│                                      │
│   模块A ──→ Interface ←── 模块B      │
│   (调用)      ↑          (实现)      │
│              │                       │
│          在中间定义                   │
│       (或由高层定义)                  │
└──────────────────────────────────────┘
```

---

### Lv-3: 聚合 (Aggregation) - 集合关系 🟡

```cpp
/**
 * 特征：整体包含部分，但不拥有所有权
 * 耦合度：⭐⭐⭐
 * 适用场景：集合容器、管理器、协调者
 */

class Entity {
public:
    void update() { /* 实体更新逻辑 */ }
};

class Scene {
    std::vector<Entity*> entities_;  // 外部创建的实体
    
public:
    void addEntity(Entity* e) {
        entities_.push_back(e);
    }
    
    void removeEntity(Entity* e) {
        entities_.erase(
            std::remove(entities_.begin(), entities_.end(), e),
            entities_.end()
        );
    }
    
    void updateAll() {
        for (auto* e : entities_) {
            e->update();  // 操作实体
        }
    }
    
    // ✓ 不负责delete entities
    // ✓ 整体-部分语义
    // ✓ 灵活的成员管理
};

// 使用示例
int main() {
    Scene scene;
    
    Entity e1, e2, e3;
    scene.addEntity(&e1);
    scene.addEntity(&e2);
    scene.addEntity(&e3);
    
    scene.updateAll();
    
    scene.removeEntity(&e2);
    
    // e1, e2, e3在scene之外管理生命周期
}
```

**优势：**
- ✅ 灵活的成员管理
- ✅ 多个容器可共享同一对象
- ✅ 适合动态集合

**注意事项：**
- ⚠️ 需明确所有权归属
- ⚠️ 避免悬空指针
- ⚠️ 文档中说明生命周期责任

---

### Lv-4: 组合 (Composition) - 强耦合 🟠

```cpp
/**
 * 特征：完全拥有部件，生命周期绑定
 * 耦合度：⭐⭐⭐⭐
 * 适用场景：仅用于模块内部！
 * 
 * ⚠️ 跨模块边界禁止使用组合！
 * 
 * 为什么跨模块禁止组合？
 * 组合 = 所有权 + 生命周期绑定
 * 
 * 跨模块组合的问题：
 * 1. 模块A拥有模块B对象 → 两个模块生命周期强绑定
 * 2. 无法独立编译测试ModuleA（必须依赖ModuleB）
 * 3. 换ModuleB实现需要重新编译ModuleA
 * 4. 违反模块独立性原则
 * 
 * 正确做法：跨模块用接口+依赖注入（Lv-2 实现）
 */

class Engine {
public:
    void start() { std::cout << "Engine started\n"; }
};

class Wheel {
    double diameter;
public:
    Wheel(double d) : diameter(d) {}
    void rotate() { std::cout << "Wheel rotating\n"; }
};

class GPS {
public:
    void navigate() { std::cout << "Navigating...\n"; }
};

class Car {
    // 值成员：完全拥有
    Engine engine_;        
    Wheel wheels_[4];      
    
    // 智能指针：拥有所有权
    std::unique_ptr<GPS> gps_;
    
public:
    Car() 
        : engine_()
        , wheels_{Wheel(20), Wheel(20), Wheel(20), Wheel(20)}
        , gps_(std::make_unique<GPS>())
    {
        // Car创建时，所有部件同时创建
    }
    
    // Car销毁时，所有部件自动销毁
    ~Car() {
        // engine_, wheels_ 自动销毁
        // gps_ 通过unique_ptr自动delete
    }
    
    void drive() {
        engine_.start();
        for (auto& wheel : wheels_) {
            wheel.rotate();
        }
        gps_->navigate();
    }
};

// Engine、Wheel、GPS 的生命周期完全由Car控制
```

**优势：**
- ✅ 强整体-部分关系明确
- ✅ 生命周期自动管理（RAII）
- ✅ 实现细节完全封装

**限制：**
- ⚠️ **仅用于模块内部**
- ⚠️ **跨模块禁止组合**
- ⚠️ 高耦合，难以替换部件

**黄金法则：**
```
组合 = 所有权 + 生命周期绑定

✓ 模块内部：Car组合Engine（可以）
✗ 跨模块：ServiceA组合ServiceB（禁止！）

原因：跨模块组合导致：
  - 模块边界被破坏
  - 无法独立部署
  - 测试困难
  - 高度耦合
```

---

### Lv-5: 继承 (Inheritance) - 最强 🔴

```cpp
/**
 * 特征：is-a关系，编译时绑定
 * 耦合度：⭐⭐⭐⭐⭐ (最高)
 * 适用场景：极少！必须满足严格条件
 * 
 * ⚠️⚠️⚠️ 慎用继承！优先考虑组合 ⚠️⚠️⚠️
 * ⚠️⚠️⚠️ 跨模块边界禁止继承！ ⚠️⚠️⚠️
 */

// ✅ 正确使用：接口多态
class Shape {  // 抽象基类
public:
    virtual ~Shape() = default;  // ✓ 虚析构函数
    virtual void draw() const = 0;
    virtual double area() const = 0;
};

class Circle : public Shape {  // Circle is-a Shape
    double radius_;
public:
    Circle(double r) : radius_(r) {}
    
    void draw() const override {
        std::cout << "Drawing circle\n";
    }
    
    double area() const override {
        return 3.14159 * radius_ * radius_;
    }
};

class Rectangle : public Shape {  // Rectangle is-a Shape
    double width_, height_;
public:
    Rectangle(double w, double h) : width_(w), height_(h) {}
    
    void draw() const override {
        std::cout << "Drawing rectangle\n";
    }
    
    double area() const override {
        return width_ * height_;
    }
};

// 使用多态
void drawAll(const std::vector<Shape*>& shapes) {
    for (const auto* shape : shapes) {
        shape->draw();  // 运行时多态
    }
}

// ❌ 错误使用：仅为代码复用
class Stack : public std::vector<int> {  // ❌ Stack is-a Vector?
    // 问题：暴露了vector的所有方法
    // 问题：Stack不应该支持随机访问
};

// ✅ 应该用组合
class Stack {
    std::vector<int> data_;  // 组合
public:
    void push(int x) { data_.push_back(x); }
    int pop() { 
        int x = data_.back(); 
        data_.pop_back(); 
        return x; 
    }
    // 只暴露Stack需要的接口
};
```

**使用继承的5个必要条件（全部满足才可用）：**

| # | 条件 | 说明 | 检验方法 |
|---|------|------|----------|
| 1 | **is-a关系** | 子类确实是父类的一种 | "Circle is a Shape" 成立吗？ |
| 2 | **需要多态** | 运行时需要替换不同实现 | 需要通过基类指针调用吗？ |
| 3 | **复用实现** | 需要继承父类的通用代码 | 有共同行为需要复用吗？ |
| 4 | **浅层次** | 继承深度 ≤ 3层 | 层次是否太深？ |
| 5 | **虚析构** | 基类有`virtual ~Base()` | 基类析构函数是虚的吗？ |

**继承的问题：**
```
❌ 子类依赖父类实现细节（脆基类问题）
❌ 改变父类影响所有子类
❌ 编译时绑定，缺乏灵活性
❌ 容易违反里氏替换原则(LSP)
❌ 跨模块继承破坏边界
```

**替代方案：**
```cpp
// 不要这样（继承仅为复用）
class Logger : public FileWriter {
    void log(const std::string& msg) {
        write(msg);  // 复用FileWriter的write
    }
};

// 应该这样（组合）
class Logger {
    FileWriter writer_;  // 组合
public:
    void log(const std::string& msg) {
        writer_.write(msg);  // 委托
    }
};
```

**跨边界继承禁令：**
```
┌─────────────────────────────────────────────────────────────┐
│   ⚠️ 跨模块/服务禁止继承！                                   │
│                                                              │
│   模块A的类 ✗ 继承 模块B的类                                 │
│                                                              │
│   原因详解：                                                  │
│                                                              │
│   1. 破坏模块封装                                             │
│      子类可以访问父类的protected成员                          │
│      → 模块B的内部实现泄漏给模块A                             │
│                                                              │
│   2. 无法独立演化                                             │
│      修改父类（模块B）→ 必须重新编译子类（模块A）             │
│      → 两个模块捆绑在一起                                     │
│                                                              │
│   3. 版本兼容性噩梦                                           │
│      父类改变内部实现 → 子类代码崩溃                          │
│      → 必须同时升级两个模块                                   │
│                                                              │
│   4. 测试困难                                                 │
│      测试子类必须依赖父类的具体实现                           │
│      → 无法Mock，变成集成测试                                 │
│                                                              │
│   5. ABI兼容问题                                              │
│      虚函数表布局变化 → 二进制不兼容                          │
│                                                              │
│   实际案例：                                                  │
│   团队A: OrderService (订单模块)                             │
│   团队B: PaymentProcessor (支付模块)                         │
│   如果OrderService继承PaymentProcessor：                      │
│   - 团队B修改PaymentProcessor内部 → 团队A代码崩溃            │
│   - 无法独立部署 → 必须协调发布                               │
│   - 测试OrderService需要真实PaymentProcessor                 │
│                                                              │
│   正确做法：通过接口交互                                      │
│   OrderService依赖IPaymentService接口                        │
│   PaymentProcessor实现IPaymentService                        │
│   → 两个模块完全解耦                                          │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

### 依赖选择决策树

```
           需要建立关系？
                ↓
         ┌──────┴──────┐
         是            否 → 不需要依赖
         ↓
    是否临时使用？
         ↓
    ┌────┴────┐
    是        否
    ↓         ↓
Lv-0依赖✓  需要长期引用？
    |          ↓
    |     ┌────┴────┐
    |     是        否
    |     ↓         → 重新考虑设计
    | 是否控制生命周期？
    |     ↓
    | ┌───┴───┐
    | 否      是
    | ↓       ↓
    | 能否   是否
    | 通过   is-a？
    | 接口？  ↓
    | ↓   ┌──┴──┐
    | 是  否     是
    | ↓   ↓      ↓
Lv-2实现✓ Lv-4组合 Lv-5继承
         (仅内部) (慎用！)
         Lv-3聚合
         Lv-1关联
```

---

### 跨边界依赖规则总结

| 边界类型 | 允许的关系 | 禁止的关系 | 原因 |
|----------|-----------|-----------|------|
| **跨服务** | Lv-0 依赖<br>API调用<br>消息通信 | Lv-1~5 全部禁止 | 服务独立部署，共享内存不可行 |
| **跨模块** | Lv-0 依赖<br>Lv-1 关联<br>**Lv-2 实现**★ | Lv-4 组合<br>Lv-5 继承 | 破坏模块封装，高度耦合 |
| **模块内部** | Lv-0~5 皆可 | 过深继承(>3层) | 内部实现细节，可控范围 |
| **类内部** | Lv-0~5 皆可 | 循环依赖 | 类的实现细节 |

**记忆口诀：**
```
跨服务只消息，
跨模块用接口，
模块内灵活用，
继承要慎重。
```

---

## 🛡️ 第二部分：SOLID + 8项黄金法则详解

### SOLID五大原则完整解析

```
┌─────────────────────────────────────────────────────────────┐
│                      SOLID原则体系                           │
├────────┬────────────────────────────────────────────────────┤
│   S    │ Single Responsibility Principle (单一职责)         │
│        │ 一个类只有一个变化的原因                            │
│        │ 变化原因 = 职责                                     │
├────────┼────────────────────────────────────────────────────┤
│   O    │ Open-Closed Principle (开放-封闭)                  │
│        │ 对扩展开放，对修改封闭                              │
│        │ 通过抽象实现扩展                                    │
├────────┼────────────────────────────────────────────────────┤
│   L    │ Liskov Substitution Principle (里氏替换)           │
│        │ 子类可以替换父类而不破坏程序                        │
│        │ 前置条件不强化，后置条件不弱化                      │
├────────┼────────────────────────────────────────────────────┤
│   I    │ Interface Segregation Principle (接口隔离)         │
│        │ 多个专用接口优于一个通用接口                         │
│        │ 客户端不应依赖不需要的方法                          │
├────────┼────────────────────────────────────────────────────┤
│   D    │ Dependency Inversion Principle (依赖倒置)          │
│        │ 依赖抽象，而非具体实现                              │
│        │ 高层和低层都依赖抽象                                │
└────────┴────────────────────────────────────────────────────┘
```

---

#### 1. 单一职责原则 (SRP) 详解

**核心思想：** 一个类应该只有一个引起它变化的原因

```cpp
// ❌ 违反SRP：混合了多种职责
class Employee {
    std::string name;
    double salary;
    
public:
    // 职责1：计算工资（财务部门关心）
    double calculatePay() {
        return salary * 1.1;
    }
    
    // 职责2：保存数据（IT部门关心）
    void save() {
        // 数据库操作
    }
    
    // 职责3：生成报表（报表部门关心）
    std::string generateReport() {
        return "Report for " + name;
    }
};
// 问题：三个部门的需求变化都会导致修改这个类！

// ✅ 遵循SRP：按职责拆分
class Employee {
    std::string name;
    double salary;
public:
    std::string getName() const { return name; }
    double getSalary() const { return salary; }
};

class PayrollCalculator {  // 职责：工资计算
public:
    double calculatePay(const Employee& emp) {
        return emp.getSalary() * 1.1;
    }
};

class EmployeeRepository {  // 职责：数据持久化
public:
    void save(const Employee& emp) {
        // 数据库操作
    }
};

class EmployeeReportGenerator {  // 职责：报表生成
public:
    std::string generate(const Employee& emp) {
        return "Report for " + emp.getName();
    }
};
```

**SRP实践技巧：**

| 检测方法 | 说明 | 修复方法 |
|----------|------|----------|
| **描述测试** | 用一句话描述类职责，如果需要用"和"连接 | 拆分类 |
| **变化原因** | 列出可能修改类的原因，超过1个 | 按原因分离 |
| **依赖方向** | 被太多不同领域的类依赖 | 提取接口 |
| **方法分组** | 方法明显分成几组，各组很少互相调用 | 拆分为独立类 |

**目录结构反映SRP：**
```
// ❌ 按技术分层（职责混乱）
/src
  /controllers  (所有控制器)
  /services     (所有服务)
  /repositories (所有数据访问)

// ✅ 按业务领域（职责清晰）
/src
  /user-domain
    UserService.cpp
    UserRepository.cpp
    UserValidator.cpp
  /order-domain
    OrderService.cpp
    OrderRepository.cpp
    OrderCalculator.cpp
```

**SRP在嵌套职责中的应用：**

现实中，许多职责是嵌套的：一个单一职责可能由多层子职责组合而成。解决方法是**职责分层设计**。

```
┌─────────────────────────────────────────────────────────────┐
│           职责的层次化分解思维                                │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  高层职责：业务能力（What）                                   │
│      ↓                                                       │
│  中层职责：业务流程（How）                                    │
│      ↓                                                       │
│  底层职责：技术细节（Detail）                                 │
│                                                              │
│  原则：                                                       │
│  1. 每一层的类只负责本层的职责                                │
│  2. 不同层次的职责由不同的类承担                              │
│  3. 通过组合/编排协调子职责                                   │
│  4. 职责边界在同一抽象层次                                    │
│                                                              │
│  示例：用户注册流程                                           │
│  ┌──────────────────────────────────────┐                  │
│  │ UserRegistrationUseCase (高层编排)   │                  │
│  │ 职责：编排用户注册业务流程            │                  │
│  └────┬─────────┬─────────┬─────────┬───┘                  │
│       ↓         ↓         ↓         ↓                        │
│  Validator Repository EmailSvc EventBus (中层服务)          │
│  验证规则   数据访问   邮件发送  事件发布                     │
│       ↓         ↓         ↓                                  │
│  EmailValidator MySQLImpl SMTPClient (底层实现)              │
│  正则验证      SQL操作   SMTP协议                            │
│                                                              │
│  记忆口诀：                                                   │
│  职责有层次，分层来解决                                       │
│  高层编排流程，中层实现规则                                   │
│  底层技术细节，各司其职不乱                                   │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

```cpp
// 实战示例：订单处理的职责分层

// ========== 层次1：原子服务（最小职责）==========
class InventoryChecker {  // 单一职责：检查库存
    bool hasStock(int productId, int quantity) const;
};

class CouponValidator {  // 单一职责：验证优惠码
    bool isValid(const std::string& code, int userId) const;
};

// ========== 层次2：领域服务（组合职责）==========
class OrderValidator {  // 职责：组合多个验证规则
    InventoryChecker inventoryChecker_;
    CouponValidator couponValidator_;
    
    ValidationResult validate(const Order& order) const {
        // 协调多个验证器
    }
};

class PriceCalculator {  // 职责：价格计算逻辑
    PriceBreakdown calculate(const Order& order) const;
};

// ========== 层次3：应用服务（编排职责）==========
class PlaceOrderUseCase {  // 职责：编排订单处理流程
    OrderValidator validator_;
    PriceCalculator priceCalculator_;
    IInventoryService* inventoryService_;
    IPaymentGateway* paymentGateway_;
    
    OrderResult execute(const CreateOrderRequest& request) {
        // 步骤1：验证订单（委托给验证器）
        auto validationResult = validator_.validate(order);
        
        // 步骤2：计算价格（委托给计算器）
        auto pricing = priceCalculator_.calculate(order);
        
        // 步骤3：预留库存（委托给库存服务）
        inventoryService_->reserve(order.getItems());
        
        // 步骤4：处理支付（委托给支付网关）
        paymentGateway_->charge(pricing.total, request.getPaymentMethod());
        
        // 编排者只负责协调，不包含具体业务逻辑！
    }
};
```

**关键要点：**
- SRP不是让每个类只有一个方法
- 而是在**同一抽象层次**的单一职责
- 复杂职责通过**分层+分治**处理
- **编排者模式**协调子职责
- 测试困难往往说明职责太多

---

#### 2. 开放-封闭原则 (OCP) 详解

**核心思想：** 软件实体应该对扩展开放，对修改封闭

```
┌─────────────────────────────────────────────────────────────┐
│              OCP 开放-封闭原则                                │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  软件实体（类、模块、函数等）应该：                           │
│                                                              │
│     ✅ 对扩展开放 (Open for Extension)                       │
│        允许添加新功能                                         │
│                                                              │
│     ✅ 对修改封闭 (Closed for Modification)                  │
│        不修改现有代码                                         │
│                                                              │
│  核心思想：                                                   │
│  通过添加新代码来扩展功能                                     │
│  而不是修改已有的、稳定的代码                                 │
│                                                              │
│  实现方式：继承、策略、装饰、模板方法、观察者...              │
│                                                              │
│  记住：OCP不是目标，而是手段                                  │
│        为应对变化而设计，不为抽象而抽象                       │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

```cpp
// ❌ 违反OCP：每次添加新类型都要修改
class ShapeDrawer {
public:
    void drawShapes(const std::vector<Shape>& shapes) {
        for (const auto& shape : shapes) {
            if (shape.type == "Circle") {
                // 绘制圆形
            } else if (shape.type == "Rectangle") {
                // 绘制矩形
            } else if (shape.type == "Triangle") {
                // 绘制三角形  ← 每次新增都要改这里
            }
            // ... 越来越多的if-else
        }
    }
};

// ✅ 遵循OCP：通过抽象扩展
class Shape {  // 抽象
public:
    virtual ~Shape() = default;
    virtual void draw() const = 0;
};

class Circle : public Shape {
    void draw() const override {
        std::cout << "Drawing Circle\n";
    }
};

class Rectangle : public Shape {
    void draw() const override {
        std::cout << "Drawing Rectangle\n";
    }
};

class Triangle : public Shape {  // 新增类型：只需添加，无需修改
    void draw() const override {
        std::cout << "Drawing Triangle\n";
    }
};

class ShapeDrawer {
public:
    void drawShapes(const std::vector<Shape*>& shapes) {
        for (const auto* shape : shapes) {
            shape->draw();  // 多态调用，永远不需要修改
        }
    }
};
```

**OCP + 策略模式示例：**

```cpp
// 压缩策略接口
class ICompressionStrategy {
public:
    virtual ~ICompressionStrategy() = default;
    virtual std::vector<byte> compress(const std::vector<byte>& data) = 0;
};

// 具体策略：Gzip
class GzipStrategy : public ICompressionStrategy {
    std::vector<byte> compress(const std::vector<byte>& data) override {
        // Gzip压缩实现
    }
};

// 具体策略：LZ4
class LZ4Strategy : public ICompressionStrategy {
    std::vector<byte> compress(const std::vector<byte>& data) override {
        // LZ4压缩实现
    }
};

// 上下文类（对修改封闭）
class FileCompressor {
    ICompressionStrategy* strategy_;
public:
    void setStrategy(ICompressionStrategy* s) { 
        strategy_ = s; 
    }
    
    void compressFile(const std::string& filename) {
        auto data = readFile(filename);
        auto compressed = strategy_->compress(data);  // 委托给策略
        writeFile(filename + ".compressed", compressed);
    }
};

// 扩展：添加新策略（对扩展开放）
class BrotliStrategy : public ICompressionStrategy {  // 新策略
    std::vector<byte> compress(const std::vector<byte>& data) override {
        // Brotli压缩实现
    }
};
// FileCompressor无需任何修改！
```

**实现OCP的技术手段：**

| 技术 | 适用场景 | 示例 |
|------|----------|------|
| **继承/多态** | 行为变化 | Shape派生类 |
| **策略模式** | 算法替换 | 压缩策略 |
| **模板方法** | 流程框架 | 游戏循环 |
| **装饰者** | 功能叠加 | IO流装饰 |
| **观察者** | 事件响应 | UI事件系统 |

---

#### 3. 里氏替换原则 (LSP) 详解

**核心思想：** 子类对象必须能够替换父类对象，而不破坏程序正确性

```cpp
// ❌ 违反LSP：正方形不是矩形的正确子类
class Rectangle {
protected:
    int width_, height_;
public:
    virtual void setWidth(int w) { width_ = w; }
    virtual void setHeight(int h) { height_ = h; }
    int getArea() const { return width_ * height_; }
};

class Square : public Rectangle {
public:
    void setWidth(int w) override {
        width_ = height_ = w;  // 保持正方形性质
    }
    void setHeight(int h) override {
        width_ = height_ = h;
    }
};

// 问题出现：
void testRectangle(Rectangle* rect) {
    rect->setWidth(5);
    rect->setHeight(4);
    assert(rect->getArea() == 20);  // 对Rectangle成立
    // 但传入Square会失败！getArea() == 16
}

// ✅ 遵循LSP：不使用继承，使用组合
class Shape {
public:
    virtual ~Shape() = default;
    virtual int getArea() const = 0;
};

class Rectangle : public Shape {
    int width_, height_;
public:
    Rectangle(int w, int h) : width_(w), height_(h) {}
    void resize(int w, int h) { width_ = w; height_ = h; }
    int getArea() const override { return width_ * height_; }
};

class Square : public Shape {
    int side_;
public:
    Square(int side) : side_(side) {}
    void resize(int side) { side_ = side; }
    int getArea() const override { return side_ * side_; }
};
// Rectangle和Square是平等的Shape，不存在替换问题
```

**LSP违反的信号：**

```
🚩 子类重写方法时：
  - 抛出父类未声明的异常
  - 接受比父类更窄的输入范围（强化前置条件）
  - 返回比父类更宽的输出范围（弱化后置条件）
  - 改变了方法的副作用

🚩 使用时需要：
  - 用instanceof检查类型
  - 向下转型（downcast）
  - 针对子类特殊处理

🚩 测试时：
  - 子类无法通过父类的测试用例
```

**LSP契约设计：**

```cpp
class Bird {
public:
    virtual ~Bird() = default;
    virtual void eat() = 0;
    // ❌ 不要定义：virtual void fly() = 0;
    // 因为企鹅不会飞，会违反LSP
};

class FlyingBird : public Bird {
public:
    virtual void fly() = 0;  // ✓ 只在会飞的鸟中定义
};

class Sparrow : public FlyingBird {
    void eat() override { /* ... */ }
    void fly() override { /* ... */ }
};

class Penguin : public Bird {  // ✓ 企鹅不继承FlyingBird
    void eat() override { /* ... */ }
    // 没有fly方法
};
```

---

#### 4. 接口隔离原则 (ISP) 详解

**核心思想：** 客户端不应该依赖它不使用的方法

```cpp
// ❌ 违反ISP：臃肿的接口
class IWorker {
public:
    virtual void work() = 0;
    virtual void eat() = 0;
    virtual void sleep() = 0;
    virtual void attendMeeting() = 0;
};

class HumanWorker : public IWorker {
    void work() override { /* ... */ }
    void eat() override { /* ... */ }
    void sleep() override { /* ... */ }
    void attendMeeting() override { /* ... */ }
};

class RobotWorker : public IWorker {
    void work() override { /* ... */ }
    void eat() override { /* 机器人不吃饭！ */ }  // ❌ 被迫实现
    void sleep() override { /* 机器人不睡觉！ */ }  // ❌ 被迫实现
    void attendMeeting() override { /* ... */ }
};

// ✅ 遵循ISP：小而精的接口
class IWorkable {
public:
    virtual ~IWorkable() = default;
    virtual void work() = 0;
};

class IFeedable {
public:
    virtual ~IFeedable() = default;
    virtual void eat() = 0;
};

class IRestable {
public:
    virtual ~IRestable() = default;
    virtual void sleep() = 0;
};

class IMeetingAttendee {
public:
    virtual ~IMeetingAttendee() = default;
    virtual void attendMeeting() = 0;
};

// 人类工人：实现所有接口
class HumanWorker : public IWorkable, 
                     public IFeedable, 
                     public IRestable,
                     public IMeetingAttendee {
    void work() override { /* ... */ }
    void eat() override { /* ... */ }
    void sleep() override { /* ... */ }
    void attendMeeting() override { /* ... */ }
};

// 机器人：只实现需要的接口
class RobotWorker : public IWorkable, 
                     public IMeetingAttendee {
    void work() override { /* ... */ }
    void attendMeeting() override { /* ... */ }
    // ✓ 不需要实现eat/sleep
};
```

**ISP实践：接口分离策略**

```cpp
// 文件操作的接口分离
class IReadable {
public:
    virtual std::string read() = 0;
};

class IWritable {
public:
    virtual void write(const std::string& data) = 0;
};

class ISeekable {
public:
    virtual void seek(size_t pos) = 0;
};

// 只读文件：只实现读
class ReadOnlyFile : public IReadable {
    std::string read() override { /* ... */ }
};

// 只写日志：只实现写
class LogFile : public IWritable {
    void write(const std::string& data) override { /* ... */ }
};

// 完整文件：实现所有
class RandomAccessFile : public IReadable, 
                          public IWritable, 
                          public ISeekable {
    std::string read() override { /* ... */ }
    void write(const std::string& data) override { /* ... */ }
    void seek(size_t pos) override { /* ... */ }
};
```

---

#### 5. 依赖倒置原则 (DIP) 深度解析

**核心思想：** 
1. 高层模块不依赖低层模块，都依赖抽象
2. 抽象不依赖细节，细节依赖抽象

**跨模块接口位置策略：**

```
┌─────────────────────────────────────────────────────────────┐
│              接口归属的黄金法则                               │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  理想情况：接口由需求方（高层）定义                           │
│                                                              │
│  现实约束：底层库不能依赖高层库（构建系统限制）               │
│                                                              │
│  解决方案：                                                   │
│                                                              │
│  策略1：独立接口层（最优）⭐⭐⭐⭐⭐                           │
│  ┌─────────────┐                                            │
│  │ Application │  ← 高层                                    │
│  └──────┬──────┘                                            │
│         │ depends                                           │
│         ↓                                                    │
│  ┌─────────────┐  ← 接口层（独立库）                        │
│  │ Interfaces  │     只有头文件                             │
│  └──────▲──────┘                                            │
│         │ implements                                        │
│  ┌──────┴──────┐                                            │
│  │DatabaseImpl │  ← 底层                                    │
│  └─────────────┘                                            │
│  优势：完全解耦、独立编译、易于测试                           │
│                                                              │
│  策略2：接口在底库导出（务实）⭐⭐⭐⭐                         │
│  ┌────────────┐    ┌────────────┐                          │
│  │Application │ → │ Database   │  ← 底库                    │
│  └────────────┘    │  Library   │                          │
│                    ├────────────┤                          │
│                    │ IDatabase  │  ← 导出接口                │
│                    │(public API)│                          │
│                    └────────────┘                          │
│  优势：自包含、易分发（单个.so）                             │
│                                                              │
│  策略3：插件架构（灵活）⭐⭐⭐⭐                               │
│  主程序定义接口 → 插件实现 → 运行时动态加载                  │
│  优势：零编译依赖、热插拔                                     │
│                                                              │
│  选择标准：项目规模、团队结构、构建约束、演化需求             │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

```
┌──────────────────────────────────────────────────────────┐
│           依赖倒置前 vs 倒置后                            │
├──────────────────────────────────────────────────────────┤
│  传统依赖（高层→低层）                                    │
│  ┌─────────────┐                                         │
│  │ Application │ ──────→ ┌──────────┐                   │
│  │   Layer     │         │ Database │                   │
│  │   (高层)    │         │  Layer   │                   │
│  └─────────────┘         │ (低层)   │                   │
│                          └──────────┘                   │
│  问题：Application依赖具体数据库实现                      │
│                                                          │
│  依赖倒置（都依赖抽象）                                   │
│  ┌─────────────┐                                         │
│  │ Application │                                         │
│  │   Layer     │                                         │
│  └──────┬──────┘                                         │
│         │ 依赖                                           │
│         ↓                                                │
│  ┌─────────────┐  ← 抽象层（最稳定）                     │
│  │ IRepository │                                         │
│  └──────▲──────┘                                         │
│         │ 实现                                           │
│         │                                                │
│  ┌──────┴──────────┐                                     │
│  │ DatabaseImpl    │  ← 实现层（可替换）                 │
│  └─────────────────┘                                     │
│                                                          │
│  优势：                                                   │
│  ✓ Application不知道Database存在                         │
│  ✓ 可随时替换数据库实现                                   │
│  ✓ 便于单元测试（Mock IRepository）                      │
│  ✓ 稳定的依赖方向                                        │
└──────────────────────────────────────────────────────────┘
```

**DIP完整示例：**

```cpp
// 1. 定义抽象（由高层定义）
class INotificationService {
public:
    virtual ~INotificationService() = default;
    virtual void send(const std::string& message, 
                      const std::string& recipient) = 0;
};

// 2. 高层业务逻辑（依赖抽象）
class OrderService {
    INotificationService* notifier_;  // 依赖接口
    
public:
    OrderService(INotificationService* notifier) 
        : notifier_(notifier) {}
    
    void placeOrder(const Order& order) {
        // 业务逻辑...
        
        // 通知客户（不知道具体如何通知）
        notifier_->send("Order confirmed", order.getCustomerEmail());
    }
};

// 3. 低层实现（实现抽象）
class EmailNotificationService : public INotificationService {
    void send(const std::string& message, 
              const std::string& recipient) override {
        // SMTP发送邮件
        std::cout << "Email to " << recipient << ": " << message << "\n";
    }
};

class SMSNotificationService : public INotificationService {
    void send(const std::string& message, 
              const std::string& recipient) override {
        // 短信网关发送
        std::cout << "SMS to " << recipient << ": " << message << "\n";
    }
};

// 4. 依赖注入（组装）
int main() {
    // 配置1：使用邮件通知
    EmailNotificationService emailService;
    OrderService orderService1(&emailService);
    
    // 配置2：使用短信通知
    SMSNotificationService smsService;
    OrderService orderService2(&smsService);
    
    // OrderService完全不知道底层实现细节！
}

// 5. 测试：注入Mock
class MockNotificationService : public INotificationService {
    std::vector<std::string> sentMessages;
public:
    void send(const std::string& message, 
              const std::string& recipient) override {
        sentMessages.push_back(message);
    }
    
    size_t getSentCount() const { return sentMessages.size(); }
};

void testOrderService() {
    MockNotificationService mock;
    OrderService service(&mock);
    
    service.placeOrder(order);
    
    assert(mock.getSentCount() == 1);  // 验证发送了通知
}
```

**DIP的三种注入方式：**

```cpp
class UserService {
    IDatabase* db_;
    ILogger* logger_;
    
public:
    // 方式1：构造函数注入（推荐）
    UserService(IDatabase* db, ILogger* logger) 
        : db_(db), logger_(logger) {}
    
    // 方式2：Setter注入
    void setDatabase(IDatabase* db) { db_ = db; }
    void setLogger(ILogger* logger) { logger_ = logger; }
    
    // 方式3：方法注入（临时依赖）
    void createUser(const User& user, IValidator* validator) {
        if (validator->validate(user)) {
            db_->save(user);
        }
    }
};
```

---

### 8项黄金法则总结

除了SOLID五大原则，还有三项关键实践：

#### 6. 信息隐藏（封装）

```cpp
// ❌ 违反封装：暴露内部实现
class Stack {
public:
    std::vector<int> data;  // ❌ 公开内部容器
};

// ✅ 正确封装：隐藏实现细节
class Stack {
    std::vector<int> data_;  // private
public:
    void push(int x) { data_.push_back(x); }
    int pop() { 
        int x = data_.back(); 
        data_.pop_back(); 
        return x; 
    }
    size_t size() const { return data_.size(); }
    bool empty() const { return data_.empty(); }
    // 不暴露vector的其他方法（如随机访问）
};
```

**C++封装技巧：**
- ✅ 头文件只声明公共接口
- ✅ 实现细节放在.cpp文件
- ✅ 使用Pimpl惯用法隐藏私有成员
- ✅ 前向声明减少头文件依赖

```cpp
// Widget.h
class WidgetImpl;  // 前向声明

class Widget {
    std::unique_ptr<WidgetImpl> pImpl;  // Pimpl
public:
    Widget();
    ~Widget();
    void doSomething();
    // 客户端看不到WidgetImpl的细节
};

// Widget.cpp
class WidgetImpl {
    // 所有私有成员和实现细节
    ComplexDependency dep_;
public:
    void doSomethingImpl() { /* ... */ }
};

Widget::Widget() : pImpl(std::make_unique<WidgetImpl>()) {}
Widget::~Widget() = default;
void Widget::doSomething() { pImpl->doSomethingImpl(); }
```

---

#### 7. 优先组合而非继承

```cpp
// ❌ 滥用继承：为了代码复用
class ArrayList : public std::vector<int> {
public:
    void addUnique(int x) {
        if (std::find(begin(), end(), x) == end()) {
            push_back(x);
        }
    }
};
// 问题：暴露了vector的所有方法，破坏了ArrayList的语义

// ✅ 使用组合
class UniqueList {
    std::vector<int> data_;  // 组合
public:
    void add(int x) {
        if (std::find(data_.begin(), data_.end(), x) == data_.end()) {
            data_.push_back(x);
        }
    }
    
    size_t size() const { return data_.size(); }
    
    // 只暴露需要的接口
};
```

**何时用继承 vs 组合：**

| 场景 | 推荐 | 原因 |
|------|------|------|
| 实现接口多态 | 继承 | 需要运行时多态 |
| 代码复用 | 组合 | 避免暴露不需要的方法 |
| 扩展功能 | 组合+委托 | 灵活性更高 |
| is-a关系 | 继承 | 符合语义 |
| has-a关系 | 组合 | 符合语义 |

---

#### 8. 资源所有权管理（C++特有）

```cpp
// 所有权语义清单
class ResourceManager {
    // 唯一所有权
    std::unique_ptr<Resource> owned_;
    
    // 共享所有权
    std::shared_ptr<SharedResource> shared_;
    
    // 不拥有（借用）
    Resource* borrowed_;
    const Resource& referenced_;
    
public:
    // 转移所有权
    void takeOwnership(std::unique_ptr<Resource> res) {
        owned_ = std::move(res);
    }
    
    // 共享所有权
    void shareOwnership(std::shared_ptr<SharedResource> res) {
        shared_ = res;
    }
    
    // 借用（不管理生命周期）
    void borrow(Resource* res) {
        borrowed_ = res;  // 调用者确保res有效
    }
};
```

**RAII原则：**
```cpp
class FileHandle {
    FILE* file_;
public:
    FileHandle(const char* filename) {
        file_ = fopen(filename, "r");  // 构造时获取
        if (!file_) throw std::runtime_error("Failed to open");
    }
    
    ~FileHandle() {
        if (file_) fclose(file_);  // 析构时释放
    }
    
    // 禁止拷贝
    FileHandle(const FileHandle&) = delete;
    FileHandle& operator=(const FileHandle&) = delete;
    
    // 允许移动
    FileHandle(FileHandle&& other) noexcept : file_(other.file_) {
        other.file_ = nullptr;
    }
    
    FILE* get() { return file_; }
};
```

---

## 🎨 第三部分：11个最实用的设计模式

### 设计模式分类与选择

```
┌─────────────────────────────────────────────────────────────┐
│              设计模式三大类别                                 │
├──────────────┬──────────────────────────────────────────────┤
│  创建型      │ 解决对象创建问题                              │
│  (Creational)│ Singleton, Factory, Builder                  │
├──────────────┼──────────────────────────────────────────────┤
│  结构型      │ 解决对象组合问题                              │
│  (Structural)│ Adapter, Decorator, Proxy, Flyweight         │
├──────────────┼──────────────────────────────────────────────┤
│  行为型      │ 解决对象协作问题                              │
│  (Behavioral)│ Strategy, Observer, Command, Template Method │
└──────────────┴──────────────────────────────────────────────┘
```

### 问题 → 模式映射表

| 代码异味/问题信号 | 推荐模式 | 解决方案 |
|-------------------|----------|----------|
| 大量if-else分支判断类型/策略 | **Strategy** | 封装算法族，可互换 |
| 根据状态不同行为大量分支 | **State** (策略变体) | 封装状态，状态自管理 |
| 对象创建分散复杂 | **Factory** | 集中创建逻辑 |
| 复杂对象分步构建 | **Builder** | 分离构建过程 |
| 需要全局唯一实例 | **Singleton** | 控制实例数量 |
| 接口不匹配需要适配 | **Adapter** | 转换接口 |
| 运行时动态添加功能 | **Decorator** | 包装增强 |
| 控制对象访问 | **Proxy** | 代理访问 |
| 大量细粒度对象占用内存 | **Flyweight** | 共享对象 |
| 一对多依赖通知 | **Observer** | 发布-订阅 |
| 请求需要排队/撤销/日志 | **Command** | 封装请求为对象 |
| 算法骨架固定，步骤可变 | **Template Method** | 定义骨架，延迟步骤 |

---

### 1. Strategy 策略模式（⭐⭐⭐⭐⭐）

**问题信号：**
```cpp
// ❌ 大量if-else判断算法类型
void processPayment(const std::string& type, double amount) {
    if (type == "CREDIT_CARD") {
        // 信用卡逻辑
    } else if (type == "PAYPAL") {
        // PayPal逻辑
    } else if (type == "ALIPAY") {
        // 支付宝逻辑
    }
    // 每增加一种支付方式就要修改这里 ❌
}
```

**解决方案：**
```cpp
// 策略接口
class PaymentStrategy {
public:
    virtual ~PaymentStrategy() = default;
    virtual void pay(double amount) = 0;
};

// 具体策略
class CreditCardStrategy : public PaymentStrategy {
    void pay(double amount) override {
        std::cout << "Credit Card: $" << amount << "\n";
    }
};

class PayPalStrategy : public PaymentStrategy {
    void pay(double amount) override {
        std::cout << "PayPal: $" << amount << "\n";
    }
};

class AlipayStrategy : public PaymentStrategy {
    void pay(double amount) override {
        std::cout << "Alipay: ¥" << amount * 7.0 << "\n";
    }
};

// 上下文类
class PaymentProcessor {
    PaymentStrategy* strategy_;
public:
    void setStrategy(PaymentStrategy* s) { strategy_ = s; }
    
    void process(double amount) {
        if (strategy_) {
            strategy_->pay(amount);
        }
    }
};

// 使用
CreditCardStrategy creditCard;
PaymentProcessor processor;
processor.setStrategy(&creditCard);
processor.process(100.0);  // 运行时切换算法

// ✅ 新增支付方式：只需添加新策略类，无需修改现有代码
```

**何时使用：**
- ✅ 多个算法可互换
- ✅ 需要运行时切换算法
- ✅ 消除条件判断

**注意事项：**
- ⚠️ 客户端需要知道所有策略
- ⚠️ 策略数量不宜过多

---

### 2. Observer 观察者模式（⭐⭐⭐⭐⭐）

**问题信号：**
```cpp
// ❌ 紧耦合的通知机制
class DataModel {
    View* view1_;
    View* view2_;
    Chart* chart_;
    
    void updateData(int newData) {
        data_ = newData;
        view1_->refresh();  // 直接调用
        view2_->refresh();
        chart_->redraw();
        // 每次新增观察者都要修改这里 ❌
    }
};
```

**解决方案：**
```cpp
// 观察者接口
class Observer {
public:
    virtual ~Observer() = default;
    virtual void update(int data) = 0;
};

// 主题（被观察者）
class Subject {
    std::vector<Observer*> observers_;
    int state_;
    
public:
    void attach(Observer* obs) {
        observers_.push_back(obs);
    }
    
    void detach(Observer* obs) {
        observers_.erase(
            std::remove(observers_.begin(), observers_.end(), obs),
            observers_.end()
        );
    }
    
    void setState(int newState) {
        state_ = newState;
        notify();
    }
    
    int getState() const { return state_; }
    
private:
    void notify() {
        for (auto* obs : observers_) {
            obs->update(state_);
        }
    }
};

// 具体观察者
class TextView : public Observer {
    std::string name_;
public:
    TextView(const std::string& name) : name_(name) {}
    
    void update(int data) override {
        std::cout << name_ << " received: " << data << "\n";
    }
};

class ChartView : public Observer {
    void update(int data) override {
        std::cout << "Chart updated with: " << data << "\n";
    }
};

// 使用
Subject subject;
TextView view1("View1"), view2("View2");
ChartView chart;

subject.attach(&view1);
subject.attach(&view2);
subject.attach(&chart);

subject.setState(42);  // 自动通知所有观察者
// 输出：
// View1 received: 42
// View2 received: 42
// Chart updated with: 42

// ✅ 新增观察者：只需attach，无需修改Subject
```

**何时使用：**
- ✅ 一对多依赖
- ✅ 对象状态变化需通知其他对象
- ✅ 事件驱动系统

**注意事项：**
- ⚠️ 可能导致级联更新
- ⚠️ 需防止内存泄漏（及时detach）

---

### 3. Factory Method 工厂方法（⭐⭐⭐⭐）

**问题信号：**
```cpp
// ❌ 创建逻辑散落各处
Shape* createShape(const std::string& type) {
    if (type == "circle") {
        return new Circle();
    } else if (type == "rectangle") {
        return new Rectangle();
    }
    // 每个创建点都要这样写 ❌
}
```

**解决方案：**
```cpp
// 产品接口
class Shape {
public:
    virtual ~Shape() = default;
    virtual void draw() const = 0;
};

// 具体产品
class Circle : public Shape {
    void draw() const override {
        std::cout << "Drawing Circle\n";
    }
};

class Rectangle : public Shape {
    void draw() const override {
        std::cout << "Drawing Rectangle\n";
    }
};

// 工厂接口
class ShapeFactory {
public:
    virtual ~ShapeFactory() = default;
    virtual Shape* createShape() const = 0;
};

// 具体工厂
class CircleFactory : public ShapeFactory {
    Shape* createShape() const override {
        return new Circle();
    }
};

class RectangleFactory : public ShapeFactory {
    Shape* createShape() const override {
        return new Rectangle();
    }
};

// 或者简单工厂（不够灵活，但实用）
class SimpleShapeFactory {
public:
    static Shape* createShape(const std::string& type) {
        if (type == "circle") return new Circle();
        if (type == "rectangle") return new Rectangle();
        return nullptr;
    }
};

// 使用
auto factory = std::make_unique<CircleFactory>();
Shape* shape = factory->createShape();
shape->draw();
delete shape;

// ✅ 新增形状：添加新Factory类，符合开闭原则
```

**何时使用：**
- ✅ 创建对象类型在运行时确定
- ✅ 隔离对象创建
- ✅ 支持产品族扩展

---

### 4. Builder 建造者模式（⭐⭐⭐⭐）

**问题信号：**
```cpp
// ❌ 构造函数参数过多
class HttpRequest {
public:
    HttpRequest(const std::string& url,
                const std::string& method,
                const std::map<std::string, std::string>& headers,
                const std::string& body,
                int timeout,
                bool followRedirects,
                int maxRedirects) {
        // 参数太多，易出错 ❌
    }
};
```

**解决方案：**
```cpp
// 产品类
class HttpRequest {
    std::string url_;
    std::string method_;
    std::map<std::string, std::string> headers_;
    std::string body_;
    int timeout_;
    bool followRedirects_;
    
    friend class HttpRequestBuilder;
    
public:
    void send() const {
        std::cout << method_ << " " << url_ << "\n";
        // 发送请求...
    }
};

// 建造者
class HttpRequestBuilder {
    HttpRequest request_;
    
public:
    HttpRequestBuilder& setUrl(const std::string& url) {
        request_.url_ = url;
        return *this;
    }
    
    HttpRequestBuilder& setMethod(const std::string& method) {
        request_.method_ = method;
        return *this;
    }
    
    HttpRequestBuilder& addHeader(const std::string& key, 
                                   const std::string& value) {
        request_.headers_[key] = value;
        return *this;
    }
    
    HttpRequestBuilder& setBody(const std::string& body) {
        request_.body_ = body;
        return *this;
    }
    
    HttpRequestBuilder& setTimeout(int timeout) {
        request_.timeout_ = timeout;
        return *this;
    }
    
    HttpRequestBuilder& setFollowRedirects(bool follow) {
        request_.followRedirects_ = follow;
        return *this;
    }
    
    HttpRequest build() {
        // 可在这里做验证
        if (request_.url_.empty()) {
            throw std::invalid_argument("URL is required");
        }
        return request_;
    }
};

// 使用（流式接口）
auto request = HttpRequestBuilder()
    .setUrl("https://api.example.com/users")
    .setMethod("POST")
    .addHeader("Content-Type", "application/json")
    .addHeader("Authorization", "Bearer token123")
    .setBody(R"({"name": "John"})")
    .setTimeout(5000)
    .setFollowRedirects(true)
    .build();

request.send();

// ✅ 可读性强，参数可选，易于扩展
```

**何时使用：**
- ✅ 对象包含多个可选参数
- ✅ 构建过程分步骤
- ✅ 需要验证构建参数

---

### 5. Singleton 单例模式（⭐⭐⭐）

**问题信号：**
```cpp
// ❌ 多处创建日志实例，浪费资源
Logger logger1;
Logger logger2;  // 应该共享同一实例
```

**解决方案（线程安全）：**
```cpp
// C++11 Meyers' Singleton（推荐）
class Logger {
    Logger() = default;  // 私有构造
    
public:
    // 删除拷贝和赋值
    Logger(const Logger&) = delete;
    Logger& operator=(const Logger&) = delete;
    
    static Logger& getInstance() {
        static Logger instance;  // C++11保证线程安全
        return instance;
    }
    
    void log(const std::string& message) {
        std::cout << "[LOG] " << message << "\n";
    }
};

// 使用
Logger::getInstance().log("Application started");
Logger::getInstance().log("Processing request");

// ✅ 全局唯一实例，延迟初始化，线程安全
```

**双重检查锁定版本（C++11前）：**
```cpp
class Singleton {
    static std::atomic<Singleton*> instance_;
    static std::mutex mutex_;
    
    Singleton() = default;
    
public:
    static Singleton* getInstance() {
        Singleton* tmp = instance_.load(std::memory_order_acquire);
        if (tmp == nullptr) {
            std::lock_guard<std::mutex> lock(mutex_);
            tmp = instance_.load(std::memory_order_relaxed);
            if (tmp == nullptr) {
                tmp = new Singleton();
                instance_.store(tmp, std::memory_order_release);
            }
        }
        return tmp;
    }
};
```

**何时使用：**
- ✅ 全局只需一个实例（日志、配置、缓存）
- ✅ 需要全局访问点
- ✅ 延迟初始化

**注意事项：**
- ⚠️ 可能成为全局状态，增加耦合
- ⚠️ 单元测试困难
- ⚠️ 多线程需考虑线程安全

---

### 6. Adapter 适配器模式（⭐⭐⭐⭐）

**问题信号：**
```cpp
// ❌ 第三方库接口不兼容
class LegacyPrinter {
public:
    void printDocument(const char* text) {
        std::cout << "Printing: " << text << "\n";
    }
};

// 现有接口期望
class IPrinter {
public:
    virtual void print(const std::string& content) = 0;
};
```

**解决方案：**
```cpp
// 适配器：将LegacyPrinter适配到IPrinter接口
class PrinterAdapter : public IPrinter {
    LegacyPrinter* legacy_;
    
public:
    PrinterAdapter(LegacyPrinter* legacy) : legacy_(legacy) {}
    
    void print(const std::string& content) override {
        // 转换接口
        legacy_->printDocument(content.c_str());
    }
};

// 使用
LegacyPrinter legacyPrinter;
IPrinter* adapter = new PrinterAdapter(&legacyPrinter);
adapter->print("Hello, World!");  // 统一接口

// ✅ 不修改现有代码，使不兼容接口协同工作
```

**何时使用：**
- ✅ 使用第三方库/遗留代码
- ✅ 接口不匹配
- ✅ 复用现有类但接口不符

---

### 7. Decorator 装饰者模式（⭐⭐⭐⭐）

**问题信号：**
```cpp
// ❌ 功能组合导致子类爆炸
class Window { };
class ScrollableWindow : public Window { };
class BorderedWindow : public Window { };
class ScrollableBorderedWindow : public ScrollableWindow { };
// N个功能 → 2^N 个子类 ❌
```

**解决方案：**
```cpp
// 组件接口
class Component {
public:
    virtual ~Component() = default;
    virtual void render() const = 0;
};

// 具体组件
class TextView : public Component {
public:
    void render() const override {
        std::cout << "[TextView Content]";
    }
};

// 装饰者基类
class Decorator : public Component {
protected:
    Component* component_;
    
public:
    Decorator(Component* comp) : component_(comp) {}
    
    void render() const override {
        if (component_) {
            component_->render();
        }
    }
};

// 具体装饰者
class BorderDecorator : public Decorator {
public:
    BorderDecorator(Component* comp) : Decorator(comp) {}
    
    void render() const override {
        std::cout << "┌─────────┐\n│ ";
        Decorator::render();
        std::cout << " │\n└─────────┘";
    }
};

class ScrollbarDecorator : public Decorator {
public:
    ScrollbarDecorator(Component* comp) : Decorator(comp) {}
    
    void render() const override {
        Decorator::render();
        std::cout << " [▲▼]";
    }
};

// 使用：动态叠加功能
Component* text = new TextView();
Component* bordered = new BorderDecorator(text);
Component* scrollable = new ScrollbarDecorator(bordered);

scrollable->render();
// 输出：
// ┌─────────┐
// │ [TextView Content] │ [▲▼]
// └─────────┘

// ✅ N个功能只需N个装饰类，灵活组合
```

**何时使用：**
- ✅ 动态添加/撤销功能
- ✅ 避免子类爆炸
- ✅ 功能组合灵活

---

### 8. Proxy 代理模式（⭐⭐⭐）

**问题信号：**
```cpp
// ❌ 直接访问昂贵资源
class ExpensiveImage {
public:
    ExpensiveImage(const std::string& filename) {
        loadFromDisk(filename);  // 耗时操作
    }
    void display() { /* ... */ }
};

// 即使不display也会立即加载 ❌
```

**解决方案（虚代理 - 延迟加载）：**
```cpp
class IImage {
public:
    virtual ~IImage() = default;
    virtual void display() = 0;
};

class RealImage : public IImage {
    std::string filename_;
    std::vector<byte> data_;
    
public:
    RealImage(const std::string& filename) : filename_(filename) {
        loadFromDisk();
    }
    
    void display() override {
        std::cout << "Displaying " << filename_ << "\n";
    }
    
private:
    void loadFromDisk() {
        std::cout << "Loading " << filename_ << " from disk...\n";
        // 耗时的磁盘I/O
    }
};

class ImageProxy : public IImage {
    std::string filename_;
    mutable RealImage* realImage_ = nullptr;  // 延迟加载
    
public:
    ImageProxy(const std::string& filename) : filename_(filename) {}
    
    ~ImageProxy() { delete realImage_; }
    
    void display() override {
        if (!realImage_) {
            realImage_ = new RealImage(filename_);  // 真正使用时才加载
        }
        realImage_->display();
    }
};

// 使用
IImage* image = new ImageProxy("large_photo.jpg");
// 此时还未加载图片 ✓

// ...

image->display();  // 现在才加载
// 输出：
// Loading large_photo.jpg from disk...
// Displaying large_photo.jpg
```

**其他代理类型：**
```cpp
// 保护代理：控制访问权限
class ProtectionProxy : public IDocument {
    RealDocument* doc_;
    User* currentUser_;
    
public:
    void edit() override {
        if (currentUser_->hasPermission("WRITE")) {
            doc_->edit();
        } else {
            throw std::runtime_error("Permission denied");
        }
    }
};

// 远程代理：代表远程对象
class RemoteServiceProxy : public IService {
    std::string serverUrl_;
    
public:
    Result call(const Request& req) override {
        // 通过网络调用远程服务
        return httpClient_.post(serverUrl_, req.toJson());
    }
};
```

**何时使用：**
- ✅ 延迟加载（虚代理）
- ✅ 访问控制（保护代理）
- ✅ 远程调用（远程代理）
- ✅ 智能引用（计数、日志）

---

### 9. Flyweight 享元模式（⭐⭐⭐）

**问题信号：**
```cpp
// ❌ 大量相似对象占用内存
class Character {
    char symbol_;
    std::string font_;      // 重复数据
    int fontSize_;          // 重复数据
    std::string color_;     // 重复数据
    int x_, y_;             // 独特数据
};

// 100万个字符 → 大量重复的font/fontSize/color ❌
```

**解决方案：**
```cpp
// 享元：共享的内部状态
class CharacterFlyweight {
    char symbol_;
    std::string font_;
    int fontSize_;
    std::string color_;
    
public:
    CharacterFlyweight(char symbol, const std::string& font, 
                       int size, const std::string& color)
        : symbol_(symbol), font_(font), fontSize_(size), color_(color) {}
    
    void render(int x, int y) const {  // 外部状态通过参数传入
        std::cout << "Rendering '" << symbol_ << "' at (" 
                  << x << "," << y << ") "
                  << "font=" << font_ << " size=" << fontSize_ << "\n";
    }
};

// 享元工厂：管理共享对象
class FlyweightFactory {
    std::map<std::string, CharacterFlyweight*> flyweights_;
    
public:
    CharacterFlyweight* getFlyweight(char symbol, const std::string& font,
                                      int size, const std::string& color) {
        std::string key = std::string(1, symbol) + font + 
                          std::to_string(size) + color;
        
        if (flyweights_.find(key) == flyweights_.end()) {
            flyweights_[key] = new CharacterFlyweight(symbol, font, size, color);
        }
        
        return flyweights_[key];
    }
    
    ~FlyweightFactory() {
        for (auto& pair : flyweights_) {
            delete pair.second;
        }
    }
};

// 使用
FlyweightFactory factory;

// 100万个'A'，但只创建一个Flyweight对象
for (int i = 0; i < 1000000; ++i) {
    auto* flyweight = factory.getFlyweight('A', "Arial", 12, "Black");
    flyweight->render(i % 800, i / 800);  // 外部状态（位置）不同
}

// ✅ 内存占用大幅降低：1个对象 vs 100万个对象
```

**何时使用：**
- ✅ 大量相似对象
- ✅ 对象大部分状态可共享
- ✅ 内存优化

**注意事项：**
- ⚠️ 区分内部状态（共享）和外部状态（独特）
- ⚠️ 需要工厂管理

---

### 10. Command 命令模式（⭐⭐⭐）

**问题信号：**
```cpp
// ❌ 请求和执行紧耦合
button.onClick([]() {
    document.save();  // 直接调用
});

// 无法撤销、无法排队、无法日志 ❌
```

**解决方案：**
```cpp
// 命令接口
class Command {
public:
    virtual ~Command() = default;
    virtual void execute() = 0;
    virtual void undo() = 0;
};

// 接收者
class Document {
    std::string content_;
    
public:
    void insertText(const std::string& text) {
        content_ += text;
        std::cout << "Inserted: " << text << "\n";
    }
    
    void deleteText(size_t count) {
        if (content_.size() >= count) {
            content_.erase(content_.size() - count);
            std::cout << "Deleted " << count << " chars\n";
        }
    }
    
    std::string getContent() const { return content_; }
};

// 具体命令
class InsertTextCommand : public Command {
    Document* doc_;
    std::string text_;
    
public:
    InsertTextCommand(Document* doc, const std::string& text)
        : doc_(doc), text_(text) {}
    
    void execute() override {
        doc_->insertText(text_);
    }
    
    void undo() override {
        doc_->deleteText(text_.size());
    }
};

class DeleteTextCommand : public Command {
    Document* doc_;
    size_t count_;
    std::string deletedText_;  // 保存用于undo
    
public:
    DeleteTextCommand(Document* doc, size_t count)
        : doc_(doc), count_(count) {}
    
    void execute() override {
        deletedText_ = doc_->getContent().substr(
            doc_->getContent().size() - count_
        );
        doc_->deleteText(count_);
    }
    
    void undo() override {
        doc_->insertText(deletedText_);
    }
};

// 调用者（支持撤销）
class TextEditor {
    std::vector<Command*> history_;
    int current_ = -1;
    
public:
    void executeCommand(Command* cmd) {
        cmd->execute();
        
        // 清除redo历史
        while (history_.size() > current_ + 1) {
            delete history_.back();
            history_.pop_back();
        }
        
        history_.push_back(cmd);
        current_++;
    }
    
    void undo() {
        if (current_ >= 0) {
            history_[current_]->undo();
            current_--;
        }
    }
    
    void redo() {
        if (current_ < (int)history_.size() - 1) {
            current_++;
            history_[current_]->execute();
        }
    }
};

// 使用
Document doc;
TextEditor editor;

editor.executeCommand(new InsertTextCommand(&doc, "Hello "));
editor.executeCommand(new InsertTextCommand(&doc, "World"));
// 输出：Inserted: Hello 
//      Inserted: World

editor.undo();
// 输出：Deleted 5 chars

editor.redo();
// 输出：Inserted: World

// ✅ 支持撤销/重做、命令队列、宏命令
```

**何时使用：**
- ✅ 需要撤销/重做
- ✅ 命令排队执行
- ✅ 日志记录操作
- ✅ 事务系统

---

### 11. Template Method 模板方法（⭐⭐⭐）

**问题信号：**
```cpp
// ❌ 相似流程代码重复
void processOrder() {
    validate();
    calculate();
    save();
    sendEmail();
}

void processReturn() {
    validate();
    calculate();  // 相同
    refund();     // 不同
    sendEmail();  // 相同
}
// 大量重复代码 ❌
```

**解决方案：**
```cpp
// 抽象基类定义算法骨架
class OrderProcessor {
public:
    // 模板方法：定义算法骨架
    void process() {
        validate();
        calculate();
        executeSpecificLogic();  // 延迟到子类
        sendNotification();
    }
    
protected:
    void validate() {
        std::cout << "Validating order...\n";
    }
    
    void calculate() {
        std::cout << "Calculating totals...\n";
    }
    
    void sendNotification() {
        std::cout << "Sending notification...\n";
    }
    
    // 钩子方法：子类实现
    virtual void executeSpecificLogic() = 0;
};

// 具体类实现变化的步骤
class NewOrderProcessor : public OrderProcessor {
protected:
    void executeSpecificLogic() override {
        std::cout << "Creating new order in database\n";
    }
};

class ReturnOrderProcessor : public OrderProcessor {
protected:
    void executeSpecificLogic() override {
        std::cout << "Processing refund\n";
    }
};

// 使用
OrderProcessor* processor = new NewOrderProcessor();
processor->process();
// 输出：
// Validating order...
// Calculating totals...
// Creating new order in database
// Sending notification...

// ✅ 复用公共逻辑，扩展变化部分
```

**何时使用：**
- ✅ 算法骨架固定
- ✅ 部分步骤可定制
- ✅ 避免代码重复

---

## 🔧 第四部分：质量保障与持续改进

### 并发设计考虑

```
┌─────────────────────────────────────────────────────────────┐
│              并发设计策略                                     │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  1. 数据与行为共定位                                          │
│     ├─ 每个对象管理自己的状态                                 │
│     ├─ 内部封装同步机制（mutex）                              │
│     └─ 不同实例无共享冲突                                     │
│                                                              │
│  2. Actor模型/任务模型                                        │
│     ├─ Actor拥有私有状态                                      │
│     ├─ 通过消息通信                                           │
│     ├─ 不共享内存                                             │
│     └─ 天然并发安全                                           │
│                                                              │
│  3. 不可变对象                                                │
│     ├─ const成员变量                                          │
│     ├─ 无setter方法                                           │
│     ├─ 线程安全（只读）                                       │
│     └─ 避免锁开销                                             │
│                                                              │
│  4. 锁粒度控制                                                │
│     ├─ 细粒度锁（性能好，复杂）                               │
│     ├─ 粗粒度锁（简单，性能差）                               │
│     └─ 无锁数据结构（高级）                                   │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**线程安全的对象示例：**

```cpp
class ThreadSafeCounter {
    std::atomic<int> count_{0};
    
public:
    void increment() {
        count_.fetch_add(1, std::memory_order_relaxed);
    }
    
    int get() const {
        return count_.load(std::memory_order_relaxed);
    }
};

class ThreadSafeQueue {
    std::queue<int> queue_;
    mutable std::mutex mutex_;
    std::condition_variable cv_;
    
public:
    void push(int value) {
        std::lock_guard<std::mutex> lock(mutex_);
        queue_.push(value);
        cv_.notify_one();
    }
    
    int pop() {
        std::unique_lock<std::mutex> lock(mutex_);
        cv_.wait(lock, [this]{ return !queue_.empty(); });
        int value = queue_.front();
        queue_.pop();
        return value;
    }
};
```

---

### 可测试性设计

```
┌─────────────────────────────────────────────────────────────┐
│              测试友好设计原则                                 │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ✓ 所有外部依赖通过接口                                       │
│     → 可Mock/Stub                                            │
│                                                              │
│  ✓ 构造函数注入依赖                                           │
│     → 测试时注入假对象                                        │
│                                                              │
│  ✓ 避免全局状态/单例                                          │
│     → 隔离测试环境                                            │
│                                                              │
│  ✓ 纯函数优先                                                │
│     → 无副作用，易测试                                        │
│                                                              │
│  ✓ 小方法/单一职责                                            │
│     → 测试粒度细                                              │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**测试示例：**

```cpp
// 生产代码
class UserService {
    IDatabase* db_;
    IEmailService* emailService_;
    
public:
    UserService(IDatabase* db, IEmailService* email)
        : db_(db), emailService_(email) {}
    
    void registerUser(const User& user) {
        if (db_->exists(user.getEmail())) {
            throw std::runtime_error("User already exists");
        }
        
        db_->save(user);
        emailService_->sendWelcomeEmail(user.getEmail());
    }
};

// 测试代码
class MockDatabase : public IDatabase {
    bool shouldUserExist = false;
    std::vector<User> savedUsers;
    
public:
    void setShouldUserExist(bool exists) { shouldUserExist = exists; }
    
    bool exists(const std::string& email) override {
        return shouldUserExist;
    }
    
    void save(const User& user) override {
        savedUsers.push_back(user);
    }
    
    size_t getSaveCount() const { return savedUsers.size(); }
};

class MockEmailService : public IEmailService {
    int emailsSent = 0;
    
public:
    void sendWelcomeEmail(const std::string& email) override {
        emailsSent++;
    }
    
    int getEmailsSent() const { return emailsSent; }
};

// 单元测试
void testRegisterNewUser() {
    MockDatabase mockDb;
    MockEmailService mockEmail;
    UserService service(&mockDb, &mockEmail);
    
    User user("test@example.com", "password");
    service.registerUser(user);
    
    assert(mockDb.getSaveCount() == 1);
    assert(mockEmail.getEmailsSent() == 1);
}

void testRegisterExistingUser() {
    MockDatabase mockDb;
    mockDb.setShouldUserExist(true);
    MockEmailService mockEmail;
    UserService service(&mockDb, &mockEmail);
    
    User user("existing@example.com", "password");
    
    try {
        service.registerUser(user);
        assert(false);  // 不应执行到这里
    } catch (const std::runtime_error&) {
        // 预期异常
    }
    
    assert(mockDb.getSaveCount() == 0);  // 未保存
    assert(mockEmail.getEmailsSent() == 0);  // 未发邮件
}
```

---

### 设计检查表

```
┌─────────────────────────────────────────────────────────────┐
│              每次迭代后的设计自检清单                         │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ✅ 模块暴露最小接口了吗？                                    │
│     □ 头文件只暴露必要API                                     │
│     □ 内部实现类型未泄漏                                      │
│     □ 使用Pimpl隐藏私有成员                                   │
│                                                              │
│  ✅ 新需求可以通过"添加"实现吗？                              │
│     □ 无需修改既有类                                          │
│     □ 符合开放-封闭原则                                       │
│     □ 通过策略/插件扩展                                       │
│                                                              │
│  ✅ 跨模块调用可否用Mock隔离测试？                            │
│     □ 所有依赖都是接口                                        │
│     □ 使用依赖注入                                            │
│     □ 单元测试覆盖率>80%                                      │
│                                                              │
│  ✅ 继承层次是否合理？                                        │
│     □ 层级 ≤ 3层                                              │
│     □ 基类有virtual析构函数                                   │
│     □ 满足is-a关系                                            │
│     □ 未仅为复用而继承                                        │
│                                                              │
│  ✅ 组合对象的所有权是否清晰？                                │
│     □ unique_ptr表示唯一所有权                                │
│     □ shared_ptr表示共享所有权                                │
│     □ 原始指针/引用表示借用                                   │
│     □ 遵循RAII原则                                            │
│                                                              │
│  ✅ 核心业务逻辑依赖外部细节了吗？                            │
│     □ Domain层独立于UI                                        │
│     □ Domain层独立于数据库                                    │
│     □ 通过接口访问基础设施                                    │
│                                                              │
│  ✅ 依赖关系有无环路？                                        │
│     □ 依赖图是DAG                                             │
│     □ 使用前向声明减少依赖                                    │
│     □ Include-What-You-Use                                   │
│                                                              │
│  ✅ 并发安全考虑了吗？                                        │
│     □ 识别共享状态                                            │
│     □ 同步机制明确                                            │
│     □ 无竞态条件                                              │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

### 持续演化的三阶段

```
┌─────────────────────────────────────────────────────────────┐
│           从耦合到解耦的演化路径                              │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  阶段1：显化耦合                                              │
│  ├─ 划分领域和模块边界                                        │
│  ├─ 定义明确的接口契约                                        │
│  ├─ 用接口暴露耦合点                                          │
│  └─ 目标：看清依赖关系                                        │
│                                                              │
│  阶段2：削弱耦合                                              │
│  ├─ 应用依赖倒置（DIP）                                       │
│  ├─ 使用策略/装饰模式                                         │
│  ├─ 引入事件总线解耦                                          │
│  ├─ 降低依赖强度（依赖金字塔）                                │
│  └─ 目标：松散连接                                            │
│                                                              │
│  阶段3：消减耦合                                              │
│  ├─ 自动化测试保障                                            │
│  ├─ 持续重构优化                                              │
│  ├─ 移除不必要依赖                                            │
│  ├─ 调整模块边界                                              │
│  └─ 目标：简洁设计                                            │
│                                                              │
│  → 循环往复，持续改进                                         │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

## 📚 核心概念速查表

### 耦合与依赖本质

```
耦合的本质 = 为协同而泄漏的自由度
  高耦合 = 牵一发动全身 ❌
  低耦合 = 插拔式独立 ✓

依赖的本质 = A需要B来完成功能
  强依赖 = 编译时绑定（继承）
  弱依赖 = 运行时绑定（接口）

依赖倒置的本质：
  控制权转移 + 依赖方向改变
  高层 → 抽象 ← 低层
  不稳定 → 稳定 ← 不稳定
```

### 抽象的三个层次

```
【层次1】概念抽象
  "数据库" 是抽象概念
  ├→ MySQL, PostgreSQL, MongoDB
  └→ 共同行为：连接、查询、更新

【层次2】行为抽象
  interface IDatabase {
    connect();    // 抽象行为
    query();      // 不关心怎么做
  }

【层次3】实现隐藏
  class MySQLImpl {
  private:
    MYSQL* conn;  // 外部看不见
    void parseResult();  // 外部看不见
  }
```

---

## 🎓 总结：统一的设计思维

```
┌─────────────────────────────────────────────────────────────┐
│                  设计的一致性原则                             │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  无论是宏观架构还是微观代码                                   │
│  无论是系统设计还是类设计                                     │
│  无论是服务拆分还是函数拆分                                   │
│                                                              │
│  始终遵循相同的核心原则：                                     │
│                                                              │
│  ┌────────────────────────────────────┐                    │
│  │  高内聚：相关的放在一起            │                    │
│  │  低耦合：依赖最小化且可替换        │                    │
│  │  单一职责：一个变化原因            │                    │
│  │  依赖倒置：依赖抽象而非实现        │                    │
│  │  开放封闭：扩展开放，修改封闭      │                    │
│  │  接口隔离：小而专的契约            │                    │
│  └────────────────────────────────────┘                    │
│                                                              │
│  从系统到模块到类到函数                                       │
│  递归应用这些原则                                             │
│  在不同缩放级别保持一致                                       │
│                                                              │
│  这就是统一的设计思维                                         │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**记住：设计是持续演化的过程，而非一次性完成。**

- ✅ 从简单开始
- ✅ 识别问题信号
- ✅ 应用合适模式
- ✅ 持续重构改进
- ✅ 保持代码长青

---

**愿你的代码高内聚、低耦合，系统易扩展、可维护！** 🎯
